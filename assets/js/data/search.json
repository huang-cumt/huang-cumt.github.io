[
  
  {
    "title": "Hpc学习",
    "url": "/posts/HPC%E5%AD%A6%E4%B9%A0/",
    "categories": "Learning",
    "tags": "HPC",
    "date": "2024-06-14 16:31:04 +0800",
    





    
    "snippet": "0. HPC(High Performance Computing)高性能计算学习记录参考链接1. 尝试使用std::thread优化向量加法与向量点乘运算      C/C++ 语言。        [] 多线程与锁（std::thread, pthread）  在c++中，我们可以使用std::thread类来创建线程并进行运算，我们不能或许各个子线程的返回值，因此我们可以通过传递参数地...",
    "content": "0. HPC(High Performance Computing)高性能计算学习记录参考链接1. 尝试使用std::thread优化向量加法与向量点乘运算      C/C++ 语言。        [] 多线程与锁（std::thread, pthread）  在c++中，我们可以使用std::thread类来创建线程并进行运算，我们不能或许各个子线程的返回值，因此我们可以通过传递参数地址的形式来获取我们所感兴趣的子线程的变量值。在线程中，所谓锁的概念事实上是由于子进程可能同时进行导致的内存读写问题所引入的机制。对于一块内存多个进行无法同时对其进行读写操作，因此如何避免可能会出现的多个线程同时访问同一块内存区域所带来的错误，因此引入了锁机制。  [] SIMD 指令的使用  [] OpenMP 的使用由于有部分C++基础，选择使用str::thread进行向量加法与点乘的计算可能原因二维加法与乘法计算量过小；在数组维度较小时，如长度1e6 1e7级别等，使用并行化并不会带来时间上的增益，甚至还有负面效果；即便到1e8数量级别，使用并行化的程序运行时间也仅仅只有较为微弱的优势。当数据维度增大到1e9时，并行化计算程序表现出时间增益。            向量长度      运算      未使用并行化加速运行时间      使用并行化加速运行时间                  1e8      向量求和      0.145785s      0.0114792s              1e8      向量转置乘法      0.141825s      0.0135729s              1e9      向量求和      1.47171s      0.0903245s              1e9      向量转置乘法      1.42515s      0.138204s      C++程序示例如下。#include&lt;iostream&gt;#include&lt;chrono&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;thread&gt;#include&lt;vector&gt;using namespace std;// a. 使用std::thread进行加速void Random(int *a, int len, int low, int upper){    for(int i=0; i&lt;len; i++){        a[i] = rand()%(upper-low+1) + low;    }}void new_sum_array(int *arr, int len, int *out) {  int sum = 0;  for(int i = 0; i &lt; len; ++i) {    sum += arr[i];  }  *out = sum;}// 如何使用多线程加速向量加法与向量乘法// a. 向量加法的加速：同时进行多次加法，然后对求和结果进行累积？但是结果变量的访问会出现冲突，依据向量的长度进行分段同时加法，最后再求和// 使用std::thread进行多线程处理优化int std_thread_sum_array(int *a, int len, int num_thread, int* out_in){  std::thread threads[num_thread];  int num = ceil(len/num_thread);  int sub_num[num_thread];  int out[num_thread];  for (int i = 0; i &lt; num_thread-1; i++) {      threads[i] = std::thread(new_sum_array, &amp;(a[i*num]), num, &amp;(out[i]));  }  threads[num_thread-1] = std::thread(new_sum_array, &amp;(a[(num_thread-1)*num]), len-num*(num_thread-1), &amp;(out[num_thread-1]));  for (auto&amp; t:threads){    t.join();  }  new_sum_array(out, num_thread, out_in);  return 0;}void new_dot_product(int *a, int *b, int len, int *out) {  int sum = 0;  for(int i = 0; i &lt; len; ++i) {    sum += a[i] * b[i];  }  *out = sum;}int std_thread_dot_product(int *a, int *b, int len, int num_thread, int* out_in){  std::thread threads[num_thread];  int num = ceil(len/num_thread); // 数据片长度  int sub_num[num_thread]; // 子线程计算结果储存地址  int out[num_thread];  for (int i = 0; i &lt; num_thread-1; i++) {      threads[i] = std::thread(new_dot_product, &amp;(a[i*num]), &amp;(b[i*num]), num, &amp;(out[i]));  }  threads[num_thread-1] = std::thread(new_dot_product, &amp;(a[(num_thread-1)*num]), &amp;(b[(num_thread-1)*num]),len-num*(num_thread-1), &amp;(out[num_thread-1]));  for (auto&amp; t:threads){    t.join();  }  new_sum_array(out, num_thread, out_in);  return 0;}int main(){    // 获取硬件信息    int num_thread = std::thread::hardware_concurrency();    cout &lt;&lt;\"支持线程数：\"&lt;&lt; num_thread &lt;&lt; endl;    num_thread -= 2;    // 数据初始化    int len = 1e9;    int *a = new int[len];    int *b = new int[len];    int *add_out = new int;    int *dot_out = new int;    Random(a, len, 1, 20000);    Random(b, len, 1, 20000);    // sequence sum    auto s_t1 = chrono::steady_clock::now();    new_sum_array(a, len, add_out);    auto e_t1 = chrono::steady_clock::now();    // sequence dot product    auto s_t2 = chrono::steady_clock::now();    new_dot_product(a, b, len, dot_out);    auto e_t2 = chrono::steady_clock::now();    // parallel sum    auto s_t3 = chrono::steady_clock::now();    std_thread_sum_array(a, len, num_thread, add_out);    auto e_t3 = chrono::steady_clock::now();    // parallel dot product    auto s_t4 = chrono::steady_clock::now();    std_thread_dot_product(a, b, len, num_thread, add_out);    auto e_t4 = chrono::steady_clock::now();    double time1 = std::chrono::duration&lt;double&gt;(e_t1-s_t1).count();    double time2 = std::chrono::duration&lt;double&gt;(e_t2-s_t2).count();    double time3 = std::chrono::duration&lt;double&gt;(e_t3-s_t3).count();    double time4 = std::chrono::duration&lt;double&gt;(e_t4-s_t4).count();    cout&lt;&lt;\"未使用并行化向量加法所需时间:\" &lt;&lt; time1 &lt;&lt; \"s\"&lt;&lt; endl;    cout&lt;&lt;\"使用并行化向量加法所需时间:\" &lt;&lt; time3 &lt;&lt; \"s\"&lt;&lt; endl;    cout&lt;&lt;\"未使用并行化向量乘法所需时间:\" &lt;&lt; time2 &lt;&lt; \"s\"&lt;&lt; endl;    cout&lt;&lt;\"使用并行化向量乘法所需时间:\" &lt;&lt; time4 &lt;&lt; \"s\"&lt;&lt; endl;    delete add_out, dot_out;    delete[] a, b;    return 0;}2."
  },
  
  {
    "title": "Ubuntu网卡debug",
    "url": "/posts/Ubuntu%E7%BD%91%E5%8D%A1Debug/",
    "categories": "Other",
    "tags": "Ubuntu",
    "date": "2024-05-24 14:31:18 +0800",
    





    
    "snippet": "0. 问题描述系统: Ubuntu 20.04内核版本： 6.5.0-35-generic近期在主机上新增了一块nvme固态硬盘，新装上之后有线网卡不能正常使用，wifi可以正常使用。但是一旦移除新增的硬盘，网络又可以正常使用了。下附个人解决思路与方案。先说结论：该问题疑似由ubuntu的udev规则机制引起，即在增加了新的固态硬盘之后，系统会重新分配网卡的名称，导致在网络配置文件中的网卡名...",
    "content": "0. 问题描述系统: Ubuntu 20.04内核版本： 6.5.0-35-generic近期在主机上新增了一块nvme固态硬盘，新装上之后有线网卡不能正常使用，wifi可以正常使用。但是一旦移除新增的硬盘，网络又可以正常使用了。下附个人解决思路与方案。先说结论：该问题疑似由ubuntu的udev规则机制引起，即在增加了新的固态硬盘之后，系统会重新分配网卡的名称，导致在网络配置文件中的网卡名称与实际网卡名称并不匹配，因此不能正确加载网卡配置。解决思路：  主机安装了双系统，切换到Windows后发现有线网络是可以正常使用的，排除硬件层面问题。  重新安装网卡驱动，问题仍然存在，排除驱动问题。  在不断重启中发现，有时会直接不显示网卡。对于3.中问题，解决方案如下:# 查看启用的网卡ifconfig# 查看所有网卡ifconfig -a可以看到设备存在但是没有被挂载。使用sudo vim /etc/NetworkManager/NetworkManager.conf查看文件内容，并修改managed=true,修改完毕后重启，网卡可以正常显示。[main]                                                                      plugins=ifupdown,keyfiledns = default[ifupdown]managed=false[device]wifi.scan-rand-mac-address=no解决了网卡显示的问题之后，网络问题仍然存在。  经过多次重启测试后发现，一旦新加上该硬盘，网卡名称将由enp4s0变为enp5s0，且在NetworkManager中二者的配置文件也并不通用。对于4.中现象，怀疑是由于网卡名称改变导致网络并不能正常加载，因此尝试使得网卡名称不变，方案如下：使用sudo vim /etc/default/grub打开配置文件，将GRUB_CMDLINE_LINUX=\"\"修改为GRUB_CMDLINE_LINUX=\"net.ifnames=0 biosdevname=0\"，保存并关闭后输入sudo update-grub。之后重启。该参数用于修改GRUB配置中网络接口的命名规则，net.ifnames=0参数会禁用Predictable Network Interface即可预测的网络接口的命名行为，biosdevname提供了一种网络设备命名机制，当biosdevname=0时，该工具将不会被使用。至此，重启后问题解决。"
  },
  
  {
    "title": "公式推导2",
    "url": "/posts/%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC2/",
    "categories": "",
    "tags": "",
    "date": "2024-05-20 22:01:08 +0800",
    





    
    "snippet": "1. 约束与目标函数定义，问题初步建模\\(\\begin{align}f(\\boldsymbol{x}) &amp;=\\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}}\\Re\\left\\{{\\left( \\boldsymbol{F}_N\\boldsymbol{x} \\right)}^H \\varGamma_{\\alpha,f} {\\left( \\boldsymbol{...",
    "content": "1. 约束与目标函数定义，问题初步建模\\(\\begin{align}f(\\boldsymbol{x}) &amp;=\\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}}\\Re\\left\\{{\\left( \\boldsymbol{F}_N\\boldsymbol{x} \\right)}^H \\varGamma_{\\alpha,f} {\\left( \\boldsymbol{F}_N\\boldsymbol{x} \\right)}\\right\\}\\\\&amp;=\\Re\\left\\{{\\boldsymbol{x}}^H  \\boldsymbol{S}  {\\boldsymbol{x}}\\right\\}\\end{align}\\)其中有$\\varGamma=\\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}} \\varGamma_{\\alpha,f}$ ，$\\boldsymbol{S}=\\boldsymbol{F}_N^H \\varGamma\\boldsymbol{F}_N$ 。由于循环谱的对称性，可以注意到实际上为一个实对称矩阵，即有$\\varGamma^H=\\varGamma$，因此我们有 S 为一个 Hermite 矩阵（这里并不会受到$\\boldsymbol{F}_N$特性的影响，事实上傅里叶变换矩阵是一个与酉矩阵有类似的性质，即有$\\boldsymbol{F}_N^H\\boldsymbol{F}_N=N\\boldsymbol{I}$），因此目标函数事实上构成一个复二次型。因此目标函数恒为实数。$$$$即有：\\[f(x)={\\boldsymbol{x}}^H  \\boldsymbol{S}  {\\boldsymbol{x}}\\]      检测概率建模    雷达目标检测的假设检验模型可以表征为：\\[\\left\\{\\begin{array}{ll}\\boldsymbol{H}_0: &amp; \\boldsymbol{v} = \\boldsymbol{n}\\\\\\boldsymbol{H}_1: &amp; \\boldsymbol{v} = \\alpha_T\\boldsymbol{x} + \\boldsymbol{n}\\end{array}\\right.\\]    其中$\\boldsymbol{v}$为接收到的回波，假设当前环境下噪声为高斯分布，且已知其协方差矩阵为正定矩阵$\\boldsymbol{M}$，因此依据纽曼-皮尔逊准则可以得到检测器为：\\[{\\left| \\boldsymbol{v}^H\\boldsymbol{M}^{-1}\\boldsymbol{c} \\right|}^2  \\stackrel{H_1}{\\underset{H_0}{\\gtrless}} G\\]    其中$G$为在给定虚警概率$P_{fa}$下的检测阈值，且有检测概率为：\\[P_d = Q \\left(\\sqrt{2 {\\left|\\alpha_T\\right|}^2\\boldsymbol{c}^H\\boldsymbol{M}^{-1}\\boldsymbol{c} },\\sqrt{-2 \\ln{P_{fa}}}\\right)\\]    因此对于给定的协方差矩阵，检测概率仅仅依赖于信干噪比，即有：    \\(\\text{SINR}={\\left|\\alpha_T\\right|}^2\\boldsymbol{c}^H\\boldsymbol{M}^{-1}\\boldsymbol{c}\\)最大化检测概率即最大化$\\text{SINR}$值。        相似度约束建模    一些常用的雷达波形拥有较为良好的性质，假设给定的参考波形为$\\boldsymbol{x}_0$，因此我们可以设置波形相似度约束有：\\({\\left\\|\\boldsymbol{x}-\\boldsymbol{x}_0 \\right\\|}^2 \\leq \\varepsilon\\)其中$\\varepsilon$为指定的波形相似度参数，用于控制波形可设计的范围大小。    注意到事实上我们有：\\({\\left\\|\\boldsymbol{x}-\\boldsymbol{x}_0 \\right\\|}^2={\\left(\\boldsymbol{x}-\\boldsymbol{x}_0 \\right)}^H {\\left(\\boldsymbol{x}-\\boldsymbol{x}_0 \\right)}=\\boldsymbol{x}^H\\boldsymbol{x}+\\boldsymbol{x}_0^H\\boldsymbol{x}_0-\\boldsymbol{x}^H\\boldsymbol{x}_0-\\boldsymbol{x}_0^H\\boldsymbol{x}\\)假设我们的目标波形与参考波形均满足恒模约束，此时我们有上式的等价表示：\\(\\Re (\\boldsymbol{x}^H\\boldsymbol{x}_0) \\geq 1-\\frac{\\varepsilon}{2}\\)此外，雷达波形通常希望最大化输出功率以提升目标探测性能，因此我们需要有恒模约束有：\\({\\left\\| \\boldsymbol{x} \\right\\|}^2=1\\)        频谱约束建模    假设给定一个初始波形，给定一组阻带约束集合考虑阻带约束下频带内的能量，有：\\(\\int_{f_1^k}^{f_2^k}{S_x(f) ~\\text{d}f}=\\boldsymbol{x}^H \\boldsymbol{R}_{s,k}\\boldsymbol{x}\\)    其中有$S_x(f)={\\left| \\sum\\limits_{n=0}\\limits^{N-1}{x(n)e^{-2j2\\pi fn}} \\right|}^2$为信号的能量谱密度。且有：\\(\\boldsymbol{R}_{s,k}=\\left\\{\\begin{array}{ll}f_2^{k}-f_1^{k} &amp; m=l \\\\\\frac{e^{j2\\pi f_2^{k}(m-l)}-e^{j2\\pi f_1^{k}(m-l)}}{j2\\pi (m-l)} &amp;m\\neq l\\end{array}\\right.\\quad, (m,l)\\in \\left\\{1,\\ldots,N\\right\\}^2\\)假设给定一组阻带约束集合$\\left{ [f_1^1,f_2^1,\\right],\\ldots,[f_1^K, f_2^K]}$，因此我们有阻带内能量为：\\(E_s=\\sum_{k=1}^{K}\\boldsymbol{x}^H\\boldsymbol{R}_{s,k}\\boldsymbol{x}\\)  ​\t此时对于多阻带约束，我们有：\\(\\boldsymbol{R}_s=\\sum_{k=1}^{K}w_k\\boldsymbol{R}_{s,k}\\)​\t其中$w_k$是我们对于多个阻带的权重约束。假设我们希望阻带内的最大能量为$E_s$，因此我们可以得到约束：\\(\\boldsymbol{x}^H\\boldsymbol{R}_{s}\\boldsymbol{x}\\leq E_s\\)下面我们定义在给定这些条件下的WCFS建模分析：\\(\\mathscr{P}_1\\left\\{\\begin{array}{ll}\\min\\limits_{\\boldsymbol{x}} &amp; {\\boldsymbol{x}}^H  \\boldsymbol{S}  {\\boldsymbol{x}} \\\\\\text{s.t.} &amp; \\begin{array}{l} \\boldsymbol{x}^H\\boldsymbol{x}=1 \\\\ \\Re (\\boldsymbol{x}^H\\boldsymbol{x}_0) \\geq 1-\\frac{\\varepsilon}{2} \\\\\\boldsymbol{x}^H\\boldsymbol{R}_{s}\\boldsymbol{x}\\leq E_s\\end{array}\\end{array}\\right.\\)2. 问题形式化简首先对于相似性约束进行松弛，其在形式上并不能够使用这种方式进行处理，考虑到${|\\boldsymbol{x}^H\\boldsymbol{x}_0|}^2= \\boldsymbol{x}^H\\boldsymbol{x}_0\\boldsymbol{x}_0^H\\boldsymbol{x}={\\Re{(\\boldsymbol{x}^H\\boldsymbol{x}_0)}}^2+{\\Im{(\\boldsymbol{x}^H\\boldsymbol{x}_0)}}^2 \\geq {\\Re{(\\boldsymbol{x}^H\\boldsymbol{x}_0)}}^2 \\geq (1-\\frac{\\varepsilon}{2})^2$。我们考虑对其进行松弛，有：\\(\\boldsymbol{x}_0^H \\boldsymbol{R}_0 \\boldsymbol{x} \\geq \\delta\\)其中，$\\delta=(1-\\frac{\\varepsilon}{2})^2$，$\\boldsymbol{R}_0=\\boldsymbol{x}_0\\boldsymbol{x}_0^H$，因此我们可以得到\\[\\mathscr{P}_2\\left\\{\\begin{array}{ll}\\min\\limits_{\\boldsymbol{x}} &amp; {\\boldsymbol{x}}^H  \\boldsymbol{S}  {\\boldsymbol{x}} \\\\\\text{s.t.} &amp; \\begin{array}{l} \\boldsymbol{x}^H\\boldsymbol{x}=1 \\\\ \\boldsymbol{x}_0^H \\boldsymbol{R}_0 \\boldsymbol{x} \\geq \\delta \\\\\\boldsymbol{x}^H\\boldsymbol{R}_{s}\\boldsymbol{x}\\leq E_s\\end{array}\\end{array}\\right.\\]下面我们考虑问题$\\mathscr{P}_2$，注意到其中的恒模约束以及目标函数较难处理。注意到目标函数事实上为一个实数，且考虑到$\\text{tr}(\\boldsymbol{A}\\boldsymbol{B})=\\text{tr}(\\boldsymbol{A}\\boldsymbol{B})$，其中$\\text{tr}(\\cdot)$为矩阵的迹函数，因此我们有\\({\\boldsymbol{x}}^H  \\boldsymbol{S}  {\\boldsymbol{x}}= \\text{tr}({\\boldsymbol{x}}^H  \\boldsymbol{S}  {\\boldsymbol{x}})= \\text{tr}(\\boldsymbol{S}  {\\boldsymbol{x}} {\\boldsymbol{x}}^H)= \\text{tr}(\\boldsymbol{S}  {\\boldsymbol{X}})\\)其中$\\boldsymbol{X}={\\boldsymbol{x}} {\\boldsymbol{x}}^H$。利用相似的原理，我们可以将$\\mathscr{P}_2$等价表示为：\\(\\mathscr{P}_3\\left\\{\\begin{array}{ll}\\min\\limits_{\\boldsymbol{X}} &amp; \\text{tr}(\\boldsymbol{S}  {\\boldsymbol{X}}) \\\\\\text{s.t.} &amp; \\begin{array}{l} \\text{tr}({\\boldsymbol{X}})=1 \\\\ \\text{tr}(\\boldsymbol{R}_0 {\\boldsymbol{X}}) \\geq \\delta \\\\\\text{tr}(\\boldsymbol{R}_{s}  {\\boldsymbol{X}})\\leq E_s\\end{array}\\end{array}\\right.\\)针对于这一问题，我们忽略掉秩一约束求解出矩阵$\\boldsymbol{X}$，再对于矩阵$\\boldsymbol{X}$进行秩一分解可以求解出最后的信号$\\boldsymbol{x}$。对于忽略掉秩一约束后的问题，有：\\(\\mathscr{P}_4\\left\\{\\begin{array}{ll}\\min\\limits_{\\boldsymbol{X}} &amp; \\text{tr}(\\boldsymbol{S}  {\\boldsymbol{X}}) \\\\\\text{s.t.} &amp; \\begin{array}{l} \\text{tr}(\\boldsymbol{R}_0 {\\boldsymbol{X}}) \\geq \\delta \\\\\\text{tr}(\\boldsymbol{R}_{s}  {\\boldsymbol{X}})\\leq E_s\\end{array}\\end{array}\\right.\\)其是一个典型的凸优化问题，我们可以使用内点法对其进行求解。引入对数障碍函数：\\(L_b(\\cdot)=-\\frac{1}{t}\\log(-f(\\cdot))\\)其中$t&gt;0$为控制因子，即有：\\(L(\\boldsymbol{X})=\\text{tr}(\\boldsymbol{S}  {\\boldsymbol{X}})-\\frac{1}{t}\\log(\\text{tr}(\\boldsymbol{R}_0 {\\boldsymbol{X}})-\\delta)-\\frac{1}{t}\\log(E_s-\\text{tr}(\\boldsymbol{R}_{s}  {\\boldsymbol{X}}))\\)令其导数为0可以得到：\\(\\boldsymbol{X}=\\boldsymbol{S}-\\frac{1}{t}\\frac{\\boldsymbol{R}_0}{\\text{tr}(\\boldsymbol{R}_0 {\\boldsymbol{X}})-\\delta}+\\frac{1}{t}\\frac{\\boldsymbol{R}_s}{E_s-\\text{tr}(\\boldsymbol{R}_{s}  {\\boldsymbol{X}})}\\)采用迭代算法可以求解。可以注意到，我们最终所获得的矩阵肯定是一个Hermitian矩阵（其事实上为三个矩阵的加权和，而三个矩阵都是Hermitian矩阵）。得到$\\boldsymbol{X}$矩阵后，我们采用秩一矩阵分解来求解$\\boldsymbol{x}$向量，即求解该问题：\\(\\min_{x} \\quad {\\left\\| \\boldsymbol{X}-\\boldsymbol{x}\\boldsymbol{x}^H \\right\\|}^2\\)对其求导我们可以解得$\\boldsymbol{x}=(\\boldsymbol{X}^H+\\boldsymbol{X})^{-1}\\frac{\\boldsymbol{X}^H\\boldsymbol{X}-1}{2}$"
  },
  
  {
    "title": "公式推导",
    "url": "/posts/%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/",
    "categories": "",
    "tags": "",
    "date": "2024-05-20 22:01:08 +0800",
    





    
    "snippet": "\\[\\begin{align}f(\\boldsymbol{x}) &amp;= \\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}} \\Re\\left\\{{\\left( \\boldsymbol{F}_N\\boldsymbol{x} \\right)}^H \\varGamma_{\\alpha,f} {\\left( \\boldsymbol{F}_N\\boldsymbol{x...",
    "content": "\\[\\begin{align}f(\\boldsymbol{x}) &amp;= \\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}} \\Re\\left\\{{\\left( \\boldsymbol{F}_N\\boldsymbol{x} \\right)}^H \\varGamma_{\\alpha,f} {\\left( \\boldsymbol{F}_N\\boldsymbol{x} \\right)}\\right\\}\\\\&amp;=\\Re\\left\\{{\\boldsymbol{x}}^H  \\boldsymbol{S}  {\\boldsymbol{x}}\\right\\}\\end{align}\\]其中有$\\varGamma = \\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}} \\varGamma_{\\alpha,f}$,$\\boldsymbol{S}=\\boldsymbol{F}_N^H \\varGamma\\boldsymbol{F}_N$。由于循环谱的对称性，可以注意到实际上为一个实对称矩阵，即有$\\varGamma^H=\\varGamma$，由于$\\boldsymbol{F}_N$为一个Hermite矩阵，因此我们有S为一个Hermite矩阵，因此目标函数事实上构成一个复二次型。我们考虑使用坐标下降法求解此问题，下面进行问题的理论分析与公式推导：假设我们的目标信号是相位编码信号，$\\boldsymbol{x} \\in \\mathbb{C}^{N\\times 1}$，$\\boldsymbol{S}\\in \\mathbb{C}^{N\\times N}$\\[\\begin{aligned}f \\left( \\boldsymbol{x} \\right) &amp;= \\Re\\left\\{{\\boldsymbol{x}}^H  \\boldsymbol{S}  {\\boldsymbol{x}}\\right\\}\\\\&amp;=\\Re\\left\\{\\sum_{m=1}^{N}\\sum_{n=1}^{N}x_m^H S_{m,n} x_n\\right\\}\\end{aligned}\\]因此我们有\\[\\begin{aligned}f\\left( x_k \\right) = &amp; \\sum_{m=1,m\\neq k}^{N} \\sum_{n=1,n\\neq k}^{N} \\Re \\left( {x_m^H S_{m,n} x_n} \\right) + \\Re \\left( x_k^H S_{k,k} x_k \\right) \\\\&amp; +\\sum_{m=1,m\\neq k}^{N} \\Re \\left( x_m^H S_{m,k} x_k \\right)  +\\sum_{n=1,n\\neq k}^{N} \\Re \\left( x_k^H S_{k,n} x_n \\right)\\\\\\end{aligned}\\]考虑到$x_k = e^{j\\phi_k} = \\cos\\phi_k + i \\sin\\phi_k$，令$\\beta_k = \\tan \\left( \\frac{\\phi_k}{2} \\right)$，因此我们有$x_{k,r} \\coloneqq \\Re\\left(x_k\\right) = \\frac{2\\beta_k}{1+\\beta_k^2}$,$x_{k,i}\\coloneqq \\Im\\left(x_k\\right) = \\frac{1-\\beta_k^2}{1+\\beta_k^2}$故可以得到\\[f\\left(x_{k,r},x_{k,i}\\right)=a_k (x_{k,r}^2+x_{k,i}^2) + b_k x_{k,r} + c_k x_{k,i} + d_k\\]其中有\\[\\begin{aligned}  a_k &amp;= \\Re \\left( S_{k,k} \\right) \\\\  b_k &amp;= \\sum_{n=1,n\\neq k}^{N}\\Re\\left( S_{k,n}x_n\\right) + \\sum_{m=1,m\\neq k}^{N}\\Re \\left( x_m^H S_{m,k}\\right)\\\\  c_k &amp;= \\sum_{n=1,n\\neq k}^{N}\\Im\\left( S_{k,n}x_n\\right) - \\sum_{m=1,m\\neq k}^{N}\\Im \\left( x_m^H S_{m,k}\\right) \\\\  d_k &amp;= \\sum_{m=1,m\\neq k}^{N} \\sum_{n=1,n\\neq k}^{N} \\Re \\left( {x_m^H S_{m,n} x_n} \\right) \\end{aligned}\\]带入有\\[f\\left(\\beta_k\\right) = \\frac{a_k \\beta_k^4+\\left(2a_k-c_k+d_k\\right)\\beta_k^2+2b_k\\beta_k+\\left(a_k+c_k+d_k\\right)}{1+\\beta_k^2}\\]显然，\\[f^\\prime (\\beta_k) = \\frac{4a_k\\beta_k^5-2a_k\\beta_k^4-2b_k\\beta_k^2+(2a_k-4c_k)\\beta_k+2b_k}{(1+\\beta_k^2)^2}\\]分母恒为正数，可以直接求得分子的零点即为这是一个典型的分式规划问题，我们可以使用Dinkelbach算法进行求解。由于分子为四阶多项式，分母为二阶多项式，其总是存在极值。  注意在这里$a_k$有可能取负值，针对于负值情况，此时$f(\\beta_k)$没有最小值，因为其在正负无穷两端都趋向于负无穷。  在这里，分母的正负并不能够进行判断，是否可以使用Dinkelbach算法对其进行求解？  考虑$f(x)\\propto f^\\prime(x)$  强行使用该算法是否对其进行优化？Dinkelbach算法用于求解分式规划问题，假设$f(x)=\\frac{g(x)}{h(x)}$，其中$g(x)$与$h(x)$为多项式函数，假设我们需要最小化这个目标函数。Dinkelbach算法的处理流程如下：  初始化: $\\beta_k$，$\\lambda$，$\\delta$，给定初始取值。  Step 1: 计算$\\beta_k = \\arg \\max\\limits_{x\\in \\mathcal{X}} g(\\beta_k)-\\lambda_k h(\\beta_k)$，$f(\\beta_k)$  Step 2: 判断$f(\\beta_k)\\leq \\delta$，若成立，跳转至Step 4，否则跳转至Step 3。  Step 3: 计算$\\lambda_k= \\frac{g(\\beta_k)}{h(\\beta_k)}$，跳转至Step 1  Step 4: $\\beta^* = \\beta_k$"
  },
  
  {
    "title": "Distant Sidelobe Suppression for Multi-Timeslot Wide-Gap Frequency-Hopping RFPA Radar 论文阅读",
    "url": "/posts/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%95-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-PFPA%E9%9B%B7%E8%BE%BE/",
    "categories": "科研记录",
    "tags": "论文阅读",
    "date": "2024-05-18 17:13:59 +0800",
    





    
    "snippet": "论文地址: Distant Sidelobe Suppression for Multi-Timeslot Wide-Gap Frequency-Hopping RFPA Radar期刊/会议: IEEE Transactions on Aerospace and Electronic Systems发表时间: 20240. 前言随机频率与脉冲重复间隔捷变(Random frequency ...",
    "content": "论文地址: Distant Sidelobe Suppression for Multi-Timeslot Wide-Gap Frequency-Hopping RFPA Radar期刊/会议: IEEE Transactions on Aerospace and Electronic Systems发表时间: 20240. 前言随机频率与脉冲重复间隔捷变(Random frequency and pulse repetition interval agile, RFPA)雷达信号有良好的低截获与抗干扰特性。但是其在距离维上存在着较多的旁瓣，这限制了它的应用。该文章提出了一种多时隙、宽间隔频率跳变序列(wide-gap frequency-hopping sequence, WGFHS)用于抑制距离旁瓣。频域分析显示其会遭到多个临近脉冲的回波能量泄露带来的影响，该文章受无线通信中临近信道干扰抑制启发，其提出了一种子带外(out-of-subband)能量泄露抑制方法，其利用子带集特性构成了一个优化问题，并利用坐标下降法对其进行了求解。1. 问题建模对于一个$m$个传输脉冲的RFPA雷达，其第$m$个传输脉冲可以被表示为:\\[s_T \\left( m,t \\right) = g_m \\left( t-t_m \\right)e^{j\\left(2\\pi f_mt+\\phi_0\\right)},m\\in\\mathcal{M}=\\left\\{0,1,\\ldots,M-1\\right\\}\\]其中$t_m$与$f_m$为第m个子脉冲的随机的起始时间与载波频率。      $t_m = m T_R + T_m$，其中$T_R$是平均PRI，且有$T_m\\in \\left[0,T_J\\right]$为随机的PRI捷变值，$T_J$是PRI捷变的最大值。        $f_m = \\left[ f_C-\\frac{B}{2},f_C + \\frac{B}{2} \\right]$，其中$f_C$是中心载波频率，$B$是频率捷变的范围。  此外$\\phi_0$为初始相位，$g_m\\left(t\\right)$表示第$m$个传输脉冲的基带波形。且有其支撑集为$supp\\left(g_m\\right)=\\left[0,T_W\\right]$  $supp\\left(\\cdot \\right)$函数表示支撑集，即英文support的缩写。支撑集为满足$\\left{ x\\in X \\vert f\\left( x\\right)\\neq 0 \\right}的集合。$一些文献中通常采用矩形窗函数，即：\\[g_m(t) = \\mu\\left( \\frac{t}{T_W}\\right)\\]其中:\\[\\mu \\left( t\\right) = \\left\\{\\begin{aligned}1,\\quad&amp; t\\in \\left[ 0,1 \\right] \\\\0,\\quad&amp; \\text{otherwise}\\end{aligned}\\right.\\]因此，我们可以将回波信号表示为:\\[s_R\\left(t\\right) = \\sum_{m=0}^{M-1}\\sum_{l=0}^{L_{max}}\\sum_{k=-K}^{K}x_{l,k}s_T\\left[ m,t-\\frac{2\\left(l\\Delta r-k\\Delta vt\\right)}{c} \\right]\\]其中，$x_{l,k}$是目标在$t=0$时刻第$\\left(l,k\\right)$个距离-速度单元的复散射系数，对于该距离-速度单元的径向距离与径向速度分别为$l\\varDelta r$与$k\\varDelta v$，其中$\\varDelta r$与$\\varDelta v$分别为距离与速度单元间隔。$L_{max}$为探测最大距离单元数目，$K$为探测最大速度单元数目。假设$T_S\\leq \\frac{1}{2B}$为采样间隔，采样时间为$t_{n,p} = t_n + pT_S$，其中$t_n$为第$n$个传输脉冲的起始时间，$p$为采样间隔数目，这表示在$t_{n,p}$时刻接收到第$n$个传输脉冲的回波，且距离发射时经过了$p$个采样时间间隔。我们可以得到解调后的第$n$个传输脉冲为:\\[y_B\\left(n,p\\right) = \\sum_{m=0}^{M-1}\\sum_{l=0}^{L_{max}}\\sum_{k=-K}^{K}x_{l,k}s_{m,l,k}\\left(n,p\\right)+e\\left(n,p\\right)\\]其中$e\\left( n,p \\right)$为采样噪声，且有:\\[\\begin{aligned}s_{m,l,k}\\left(n,p\\right) &amp;= s_T\\left(m, t_{n,p}-\\frac{2\\left(l\\varDelta r-k\\varDelta v t_{n,q}\\right)}{c}\\right) e^{-j2\\pi f_n t_{n,p}} \\\\&amp;\\approx s_T\\left(m, t_{n,p}-\\frac{2\\left(l\\varDelta r-k\\varDelta v t_{n}\\right)}{c}\\right) e^{-j2\\pi f_n t_{n,p}}\\end{aligned}\\]其对应于在第$(l,k)$个距离单元处的散射体第$m$个传输脉冲的反射回波，并使用第$n$个传输脉冲的载波进行解调。当多普勒效应导致的脉冲拉伸/频移以及脉内相移可以忽略不计时，上式中的$\\approx$成立。即有$s_{m,l,k}\\left(n,p\\right) $是时延、频移后的$s_T\\left(m,t_{n,p}\\right)$。回波信号$y_B\\left(n,p\\right)$可以进行如下分解:\\[\\begin{aligned}    y_B\\left(n,p\\right) =    &amp; \\sum_{l=l_0\\left(p\\right)}^{l_0\\left(p\\right)+L_W-1}\\sum_{k=-K}^{K} x_{l,k}s_{n,l,k}\\left(n,p\\right)   \\\\    &amp; +\\sum_{m=n+1}^{n+N_1}\\sum_{l=0}^{l_1\\left(p\\right)}\\sum_{k=-K}^{K} x_{l,k}s_{m,l,k}\\left(n,p\\right) \\\\    &amp; + \\sum_{m=n-N_2}^{n-1}\\sum_{l=l_2\\left(p\\right)}^{L_{max}}\\sum_{k=-K}^{K}x_{l,k}s_{m,l,k}\\left(n,p\\right)\\end{aligned}\\]其中有$N_1=\\min{\\left(N,M-1-n\\right)}$，$N_2=\\min{\\left(N,n\\right)}$，\\[N = \\lfloor \\frac{2L_{\\max}\\varDelta r/c+T_J+ T_W + 2T_M}{T_R} \\rfloor\\]\\[\\begin{aligned}l_0(p) &amp;= \\lfloor \\frac{c\\left(pT_S-T_W-T_M\\right)}{2\\Delta r} \\rfloor\\\\l_1(p) &amp;= \\lceil \\frac{c\\left(pT_S-T_R+T_J+T_M\\right)}{2\\Delta r} \\rceil\\\\l_2(p) &amp;= \\lfloor \\frac{c\\left(pT_S+T_R-T_J-T_W-T_M\\right)}{2\\Delta r} \\rfloor\\\\\\end{aligned}\\]注意到$T_W$为脉冲宽度，$T_J$为最大PRI捷变值，$T_S$为采样间隔，$T_R$为脉冲重复周期，$T_m$为第$M$个发射脉冲的时间偏移。$T_M$为一个相干处理间隔内产生的最大距离偏移带来的时延。假设最大相干处理单元为$N_{cp}$，有$T_M=\\frac{2K\\Delta v N_{cp}T_R}{c}$。且有：\\[\\frac{2k\\Delta v t_{n,p}}{c}\\in\\left[ -T_M,T_M \\right]\\]注意到，若要使$x_{l,k}s_{m,l,k}\\left(n,p\\right)\\neq 0$，则有\\[\\left\\{     \\begin{aligned}       &amp; l\\in \\left[0,L_{\\max}\\right] \\\\       &amp; k\\in \\left[-K,K \\right] \\\\       &amp; \\tau_{m,n}\\in\\left[0,T_W \\right]    \\end{aligned}\\right.\\]其中:\\[\\tau_{m,n}=pT_S-(m-n)T_R-(T_m-T_n)-\\frac{2l\\Delta r}{c}-\\frac{2k\\Delta v t_{n,p}}{c}\\]第一个条件对应于目标位于探测范围内，第二个条件对应于目标速度在探测范围内，第三个条件对应于第$m$个传输脉冲的回波恰好与第$n$个传输脉冲回波在时域上存在重叠。注意到其中$(m-n)T_R+(T_m-T_n)$对应于发射时间差，$\\frac{2l\\Delta r}{c}$对应于第$l$个距离单元处散射体的回波时延。$\\frac{2k\\Delta v t_{n,p}}{c}$对应于$k$个速度单元处散射体由于存在径向速度带来的时延。假设对于信号我们采用相位编码形式，设码元传输速率为$V_C(bit/s)$，因此有单个码元传输时间为$T_C=\\frac{1}{V_C}$，假设脉冲宽度是码元传输间隔的整数倍；因此一个脉冲内传输的码元个数可以表示为$M_W=\\frac{T_W}{T_C}=T_WV_C$。因此有相位编码信号的连续时间表示:\\[g_m(t)=\\sum_{n_c=0}^{M_W-1}{z_m(n_c)\\mu(\\frac{t-n_cT_C}{T_C})}\\]其中$z_m(n_c)=e^{j\\phi(n_c)}$对应于第$n_c$个码元。为此，我们可以得到它的频域表示:\\[G_m(f)=T_c\\text{sinc}(fT_C)\\sum_{n_c=0}^{M_W-1}z_m(n_c)e^{-j2\\pi fn_c T_C}\\]我们可以得到其在阻带中的能量为$\\int_{f_1}^{f_2}{G_m(f)}$；其中$[f_1,f_2]，f_1&lt;f_2$为阻带频率。我们可以将$G_m(f)$改写为$\\boldsymbol{z}_m$的函数，有$G_m(f)=T_c\\text{sinc}(fT_C)\\boldsymbol{S}(f),\\boldsymbol{S}(f)=[0,e^{j2\\pi f T_C},\\ldots,e^{j2\\pi fn_cT_C}]^T$，故有$\\Vert G_m(f) \\Vert^2 = \\boldsymbol{z}_m^H \\boldsymbol{S}(f)\\boldsymbol{S}(f)^H\\boldsymbol{z}_m$。因此我们可以得到在某一阻带内的能量为:\\[\\begin{aligned}\\int_{f_1}^{f_2}\\Vert G_m(f) \\Vert^2 \\text{d}f &amp;=\\int_{f_1}^{f_2}\\boldsymbol{z}_m^H \\boldsymbol{S}(f)\\boldsymbol{S}(f)^H\\boldsymbol{z}_m \\text{d}f\\\\&amp;= \\boldsymbol{z}_m^H [\\int_{f_{m,1}}^{f_{m,2}}\\boldsymbol{S}(f)\\boldsymbol{S}(f)^H\\text{d}f]\\boldsymbol{z}_m\\\\&amp;= \\boldsymbol{z}_m^H\\boldsymbol{R}_m\\boldsymbol{z}_m\\end{aligned}\\]其中有:\\[\\boldsymbol{R}_m(n_{c,1},n_{c,2})=\\int_{f_{m,1}}^{f_{m,2}}T_C^2 \\text{sinc}^2(fT_C)e^{j2\\pi f(n_{c,1}-n_{c,2})T_C}\\text{d}f\\]其中$n_{c,1},n_{c,2}\\in \\left{1,2,\\ldots,M_W\\right}$。$[f_{m,1},f_{m,2}]$为阻带，$\\text{sinc}(fT_C)=\\frac{sin(\\pi f T_C)}{\\pi f T_C}$。考虑到阻带有$f_{m,1}=f_n-f_m-f_{pass},f_{m,2}=f_n-f_m+f_{pass}$，且有$\\vert f_n-f_m \\vert \\gg f_{pass}$，因此有$\\text{sinc}(fT_C) \\approx \\frac{sin(\\pi f T_C)}{\\pi (f_n-f_m)T_C}$。现在我们考虑该积分的计算，近似处理后，我们实际需要进行积分的式子有如下形式，我们先进行其积分的推导。\\[\\begin{aligned}\\int{\\sin^2(ax)e^{bx}} \\text{d}x &amp;= \\frac{1}{b}\\sin^2(ax)e^{bx}-\\frac{1}{b}\\int2a \\sin(ax)\\cos(ax)e^{bx} \\text{d}x \\\\&amp;= \\frac{1}{b}\\sin^2(ax)e^{bx}-\\frac{a}{b}\\int \\sin(2ax)e^{bx} \\text{d}x \\\\&amp;= \\frac{1}{b}\\sin^2(ax)e^{bx}-\\frac{a}{b^2}{\\sin(2ax)e^{bx}} + \\frac{2a^2}{b^2}\\int \\cos(2ax)e^{bx} \\text{d}x \\end{aligned}\\]又因为\\[\\begin{aligned}\\int{\\sin^2(ax)e^{bx}} \\text{d}x &amp;= \\int{\\frac{1-\\cos(2ax)}{2}e^{bx}} \\text{d}x \\\\&amp; = \\frac{1}{2b}e^{bx}-\\frac{1}{2}\\int\\cos(2ax)e^{bx} \\text{d}x\\end{aligned}\\]故有\\[\\int\\cos(2ax)e^{bx} \\text{dx} = \\frac{1}{b}e^{bx}-2\\int \\sin^2(ax)e^{bx}\\text{d}x\\]结合有\\[\\int{\\sin^2(ax)e^{bx}\\text{d}x}=\\frac{b^2}{4a^2+b^2}{\\left[ \\frac{1}{b}\\sin^2(ax)e^{bx}-\\frac{a}{b^2}{\\sin(2ax)e^{bx}} + \\frac{2a^2}{b^3}e^{bx} \\right]}\\]代入$a=\\pi T_C,b=j2\\pi(n_{c,1}-n_{c,2})T_C$。因此有\\[\\int_{f_n-f_m-f_{pass}}^{f_n-f_m+f_{pass}}\\]"
  },
  
  {
    "title": "Ubuntu",
    "url": "/posts/Ubuntu/",
    "categories": "Other",
    "tags": "Ubuntu",
    "date": "2024-05-12 15:56:42 +0800",
    





    
    "snippet": "1. 开机自启动脚本设置你可以使用sudo命令来运行需要超级用户权限的脚本，并且可以通过修改sudoers文件来避免输入密码。同时，你可以通过systemd来设置开机自动运行脚本。以下是具体步骤：      打开终端，输入sudo visudo来编辑sudoers文件。        在文件末尾添加一行，格式为username ALL=(ALL) NOPASSWD: /path/to/you...",
    "content": "1. 开机自启动脚本设置你可以使用sudo命令来运行需要超级用户权限的脚本，并且可以通过修改sudoers文件来避免输入密码。同时，你可以通过systemd来设置开机自动运行脚本。以下是具体步骤：      打开终端，输入sudo visudo来编辑sudoers文件。        在文件末尾添加一行，格式为username ALL=(ALL) NOPASSWD: /path/to/your/network.sh，其中username是你的用户名，/path/to/your/network.sh是你的脚本的完整路径。这一行的意思是允许username在所有主机上以所有用户身份运行你的脚本，而不需要输入密码。        按Ctrl+X，然后按Y，最后按Enter来保存并退出。        创建一个新的systemd服务单元文件，例如/etc/systemd/system/network.service，并添加以下内容：  [Unit]Description=Network script[Service]ExecStart=sudo /path/to/your/network.sh[Install]WantedBy=multi-user.target      保存并退出，然后运行sudo systemctl enable network.service来启用服务。        重启你的电脑，你的脚本应该会在开机时自动运行。  注意：这种方法具有一定的安全风险，因为它允许你的脚本以超级用户权限运行，而不需要输入密码。请确保你的脚本是安全的，不会被恶意修改。如果可能，最好找到一种不需要超级用户权限就能运行的方法。2. 切换lighdm3与gdm切换Waylandsudo nano /etc/gdm3/custom.confsudo dpkg-reconfigure gdm3sudo service gdm3 restartWaylandEnable=false[Unit]Description = Rj Network scriptWants=network-online.targetAfter=network-online.target[Service]ExecStart = sudo /etc/userscript/rjnet.sh [Install]WantedBy = multi-user.target3. 环境变量配置环境变量配置存储在.bashrc文件中，使用vim ~/.bashrc即可编辑该文件。添加export PATH=/opt/xxx/xxx:$PATH至该文件即可，更改完毕使用source ~/.bashrc更新刚刚所完成的修改，环境变量即修改完毕。"
  },
  
  {
    "title": "Maa&ubuntu",
    "url": "/posts/MAA&Ubuntu/",
    "categories": "Other",
    "tags": "MAA",
    "date": "2024-05-12 15:55:16 +0800",
    





    
    "snippet": "0. 模拟器与容器选择1. MAA-cli安装与配置2. config文件结构",
    "content": "0. 模拟器与容器选择1. MAA-cli安装与配置2. config文件结构"
  },
  
  {
    "title": "Git指令学习",
    "url": "/posts/Git/",
    "categories": "Other",
    "tags": "Git",
    "date": "2024-04-13 15:34:19 +0800",
    





    
    "snippet": "初始化git init上传git add .git commit -m “CommitMessage”git push拉取git fetch 与 git pull的区别其它  忽略文件touch .gitignore选择不追踪文件夹中的哪些文件。  创建/切换分支指定ssh密钥连接githubLinux平台下执行sudo git push会出现的问题在Linux平台下执行sudo命令时",
    "content": "初始化git init上传git add .git commit -m “CommitMessage”git push拉取git fetch 与 git pull的区别其它  忽略文件touch .gitignore选择不追踪文件夹中的哪些文件。  创建/切换分支指定ssh密钥连接githubLinux平台下执行sudo git push会出现的问题在Linux平台下执行sudo命令时"
  },
  
  {
    "title": "ssh远程挂载文件目录",
    "url": "/posts/%E5%85%B6%E5%AE%83-%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD/",
    "categories": "Other",
    "tags": "ssh",
    "date": "2024-04-12 22:09:10 +0800",
    





    
    "snippet": "0. 前言当我们处理服务器上的数据时，上传或者下载显得很冗余且不便于编辑，此时我们可以将远程的文件目录通过 ssh 服务挂载到本地，从而在本地进行服务器端的文件编辑。在这里我们使用 SSHFS 来实现挂载。SSHFS（SSH Filesystem）是一个基于 FUSE 的文件系统客户端，用于通过 SSH 连接远程目录。SSHFS 使用的是 SFTP 协议，它是 SSH 的一个子系统，在大多数...",
    "content": "0. 前言当我们处理服务器上的数据时，上传或者下载显得很冗余且不便于编辑，此时我们可以将远程的文件目录通过 ssh 服务挂载到本地，从而在本地进行服务器端的文件编辑。在这里我们使用 SSHFS 来实现挂载。SSHFS（SSH Filesystem）是一个基于 FUSE 的文件系统客户端，用于通过 SSH 连接远程目录。SSHFS 使用的是 SFTP 协议，它是 SSH 的一个子系统，在大多数 SSH 服务器上默认启用。平台：Win111. 具体实现必选WinFspSSHFS-Win可选（提供GUI界面服务）SSHFS-Win Manager使用GUI服务安装完成后，打开SSHFS-Win Manager 软件，指定IP、用户名、授权方式即可进行连接。"
  },
  
  {
    "title": "MATLAB使用心得汇总",
    "url": "/posts/MATLAB/",
    "categories": "Other",
    "tags": "MATLAB",
    "date": "2024-04-10 09:36:10 +0800",
    





    
    "snippet": "1. 在MATLAB创建循环进度条事实上，MATLAB自带waitbar函数可以使用图窗显示进度条，可是当我们使用MATLAB提供的API调用其进行计算时，图窗并不能够显示（如使用VScode中的matlab插件），此时运行时间较长的程序则需要我们自己创建进度条以用于打印输出。关于这一点，我们可以使用MATLAB中的结构体实现这一功能，使用示例为：% Example % Include fo...",
    "content": "1. 在MATLAB创建循环进度条事实上，MATLAB自带waitbar函数可以使用图窗显示进度条，可是当我们使用MATLAB提供的API调用其进行计算时，图窗并不能够显示（如使用VScode中的matlab插件），此时运行时间较长的程序则需要我们自己创建进度条以用于打印输出。关于这一点，我们可以使用MATLAB中的结构体实现这一功能，使用示例为：% Example % Include forWaitbar.mN = 1000;mywaitbar = forWaitbar(N);for i = 1:N    pause(0.1);    mywaitbar.show_bar;end其中所需要的forWaitbar.m文件定义如下。我们使用了一个结构体来实现这一功能。classdef forWaitbar &lt; handle    properties (Access = private)        solid_square = '*'; % The symbol of completion        hollow_square = '-'; % The symbol of waiting        N; % 总循环数        temp_num; % 当前循环数        square_nums = 40; % 打印方块数        threshold; % 打印阈值        Count_p_num; % 打印计数器        s_num; % 方块计数器1        h_num; % 方块计数器2    end    methods        function obj = forWaitbar(N)        % 初始化            obj.N = N;            obj.temp_num = 0;            obj.Count_p_num = 0;            obj.s_num = 0;            obj.h_num = obj.square_nums;            obj.threshold = fix(N/obj.square_nums);        end        function show_bar(obj)            obj.Count_p_num = obj.Count_p_num + 1;            obj.temp_num = obj.temp_num + 1;            if obj.Count_p_num &gt;= obj.threshold || obj.temp_num == obj.N || obj.temp_num == 1                if ( obj.s_num ~= obj.square_nums - 1 || obj.temp_num == obj.N ) &amp;&amp; obj.temp_num &lt;= obj.N                    obj.Count_p_num = 0;                    obj.s_num = obj.s_num + 1;                    obj.h_num = obj.h_num - 1;                    obj.draw_bar;                end            end        end    end    methods (Access = private)        function draw_bar(obj)            back = repmat('\\b', [1,obj.square_nums+2+4]);            fprintf(back);            fprintf('&lt;');            if (obj.s_num &gt; 0)                for i = 1:obj.s_num                    fprintf(obj.solid_square);                end            end            if (obj.h_num &gt; 0)                for i = 1:obj.h_num                    fprintf(obj.hollow_square);                end            end            fprintf('&gt;');            precent = num2str(round((obj.temp_num/obj.N)*100));            if length(precent) &lt; 3                precent = [repmat(' ',[1,3-length(precent)]),precent];            end            fprintf([precent,'%%']);            if obj.temp_num == obj.N                fprintf('\\n');            end        end    endend2. MATLAB中调整绘图colorbar的颜色3. 并行计算parfor的使用MATLAB并行化计算功能依赖于Parallel Computing Toolbox工具箱实现，当我们使用多核处理器/GPU/计算集群时可以利用该工具箱实现并行计算，以充分利用资源。在这里仅阐述对于多核CPU的并行化计算功能，并行化计算功能只能对于for循环结构使用，且有一定限制。当我们使用多核CPU时，通常的MATLAB程序将只会调度其中一个核，可以使用parfor替换程序中的for循环结构来实现并行化。示例程序如下，两种写法均可以，其中M表示给当前parfor分配的线程数，若不指定则默认分配当前最大线程数。% Example 1parfor loopvar = initval:endval    statements;end% Example 2parfor (loopvar = initval:endval, M)    statements;end使用并行计算parfor指令的前提首先需要明确一点并不是所有程序都可以使用parfor指令，程序使用parfor指令不一定会带来处理增益。该指令事实上是将循环分组并置于不同的进程中进行同时处理，最后再进行合并。不同进程之间的通信消耗、启动服务所需要消耗的时间资源并不少，因此仅只有当循环中的计算量很大时使用parfor指令可以给程序带来增益，因为此时程序运行时间主要由循环内部计算时间控制；如果循环中代码时间复杂度并不高，不同进程处理带来的通信消耗可能会使得运行时间甚至变长。详情可参见该文档Decide When to Use parfor。了解了parfor的执行原理后，我们就知道使用parfor应该有哪些要求，由于其本质是将循环分组进行同时处理，此时如果第i次循环依赖于i次前/后的计算结果，此时不能使用parfor指令进行计算，因为此时有可能其依赖的那次计算结果尚未进行计算。此外MATLAB关于parfor有详细的介绍，参照该网页。在parfor结构中有以下几种变量。            Type      Explanation                  Loop Variables      Loop indices              Sliced Variables      Arrays whose segments are operated on by different iterations of the loop              Broadcast Variables      Variables defined before the loop whose value is required inside the loop, but never assigned inside the loop              Reduction Variables      Variables that accumulates a value across iterations of the loop, regardless of iteration order              Temporary Variables      Variables created inside the loop, and not accessed outside the loop      Loop Variables即在每次for循环中迭代的变量，循环变量loopvar必须是连续的、递增的正整数，其它形式都是不被允许的。Sliced Variables是切片向量，是每次在循环中所使用的矩阵/向量的部分元素，其不能是动态大小而必须是固定大小的。Broadcast Variables指在每个循环中被使用但是并没有被改变的变量。Reduction Variables指在每个循环中被累积的变量，并且其最终不受循环执行的顺序的影响。常见的归约操作符号有+、*、-、&amp;、|即加、减、乘、与、或等。详情可参见该文档。因此我们可以总结一些使用parfor指令的前提和要求。  循环内部计算耗时是运行时间长的主要来源。  每次循环运算相互独立，可以进行单独计算。该网页提供了一些在parfor结构中不支持的构造，较为常见的有：  parfor中嵌套parfor  使用break或continue除此之外，个人在使用中还遇到了一些其它问题。  for循环中使用parfor当我们在for循环中parfor时，MATLAB可以正常运行，但是其往往会导致内存溢出报错。4. 多线程运算myCluster = parcluster(\"Processes\");job = createJob(myCluster); N = 200;createTask(j, @MyFun1, 1, {N});createTask(j, @MyFun2, 1, {2*N});submit(j); % Submit The Taskwait(j); % Caculate The Taskresult_1 = fetchOutputs(j); % Get The Outputdestroy(j); % Delete The job5. 其他在matlab中，相较于使用cell2mat函数，使用[C{:}]来实现将cell转换为数组在计算速度上将会更快。"
  },
  
  {
    "title": "LPI Radar Waveform Design With Desired Cyclic Spectrum and Pulse Compression Properties 论文阅读",
    "url": "/posts/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%95-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB01/",
    "categories": "科研记录",
    "tags": "论文阅读",
    "date": "2024-03-15 14:50:16 +0800",
    





    
    "snippet": "论文地址：LPI Radar Waveform Design With Desired Cyclic Spectrum and Pulse Compression Properties期刊/会议：IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY发表时间：20230. 模型构建针对于相位编码信号$\\boldsymbol{x}=[x_1,x_2,\\cdots,x...",
    "content": "论文地址：LPI Radar Waveform Design With Desired Cyclic Spectrum and Pulse Compression Properties期刊/会议：IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY发表时间：20230. 模型构建针对于相位编码信号$\\boldsymbol{x}=[x_1,x_2,\\cdots,x_N]\\in \\mathbb{C}^{N}$，考虑加权循环频率谱旁瓣（weightedcyclic frequency sidelobe ，WCFS）考虑可设计目标函数为：\\[f(\\boldsymbol{x}) = \\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}} {\\left|{\\left( \\boldsymbol{F}_N\\boldsymbol{x} \\right)}^H \\varGamma_{\\alpha,f} {\\left( \\boldsymbol{F}_N\\boldsymbol{x} \\right)}\\right|}^2\\]其中$\\varGamma_{\\alpha,f}$为$N$循环谱计算矩阵。$\\boldsymbol{F_{N}}$为阶傅里叶变换矩阵。除了低截获性能外，还需考虑信号的探测性能，目前文献中针对于此类探测性能常使用相似性约束以获得和参考信号相近的旁瓣，相似度度量有最大值范数以及2-范数两种，在这里采用最大值范数度量，数学描述如下：\\[{\\Vert \\boldsymbol{x}-\\boldsymbol{c} \\Vert}_{\\infty} \\leq \\vartheta\\]其中$\\boldsymbol{c}$即为预设的参考信号，$\\vartheta$为预设相似度门限，通常需要依据经验设定，该数值越大，信号的自由度越高，相应的程序迭代次数以及运行时间越小，但是目标函数度量值将会变差。考虑复矩阵/向量的实数表示为\\[\\boldsymbol{x}_r=[\\Re(\\boldsymbol{x})^T~~\\Im(\\boldsymbol{x})^T]^T\\]\\[\\boldsymbol{c}_r=[\\Re(\\boldsymbol{c})^T~~\\Im(\\boldsymbol{c})^T]^T\\]\\[\\boldsymbol{F}_{N,r} = \\left[\\begin{matrix}\\Re (\\boldsymbol{F}_N) &amp; -\\Im (\\boldsymbol{F}_N) \\\\\\Im (\\boldsymbol{F}_N) &amp; \\Re (\\boldsymbol{F}_N) \\\\\\end{matrix}\\right]\\]相似性度量可以等价表示为：\\[{\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)}^H \\chi_{n,r} {\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)} \\leq \\vartheta\\]其中\\[\\chi_n (i,j) = \\left\\{\\begin{aligned}&amp;1 \\quad i=j=n,n\\in \\left\\{1,2,\\cdots,N\\right\\} \\\\&amp;0 \\quad otherwise\\end{aligned}\\right.\\]\\[\\chi_{n,r}=\\left[ \\begin{matrix}\\Re (\\chi_{n}) &amp; -\\Im (\\chi_{n}) \\\\\\Im (\\chi_{n}) &amp; \\Re (\\chi_{n}) \\\\\\end{matrix}\\right]\\]即对于任意$n\\in { 1,2,\\cdots,N }$均有$x_{r,n}-c_{r,n} &lt; \\vartheta$成立。相应的，目标函数可写为\\[f(\\boldsymbol{x}_r) = \\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}} \\left[{\\left|{\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}^T \\varGamma_{\\alpha,f}^1 {\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}\\right|}^2 +{\\left|{\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}^T \\varGamma_{\\alpha,f}^2 {\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}\\right|}^2 \\right]\\]其中有：\\[\\varGamma_{\\alpha,f}^1 = \\left[\\begin{matrix}\\Re (\\varGamma_{\\alpha,f}) &amp; -\\Im (\\varGamma_{\\alpha,f}) \\\\\\Im (\\varGamma_{\\alpha,f}) &amp; \\Re (\\varGamma_{\\alpha,f}) \\\\\\end{matrix}\\right],\\varGamma_{\\alpha,f}^2 = \\left[\\begin{matrix}\\Im (\\varGamma_{\\alpha,f}) &amp; -\\Re(\\varGamma_{\\alpha,f}) \\\\\\Re (\\varGamma_{\\alpha,f}) &amp; \\Im (\\varGamma_{\\alpha,f}) \\\\\\end{matrix}\\right]\\]在这里，由于本来$\\boldsymbol{x}$的实数表示应该为\\[\\begin{bmatrix}\\Re{\\left(\\boldsymbol{x}\\right)} &amp; -\\Im{\\left(\\boldsymbol{x}\\right)} \\\\\\Im{\\left(\\boldsymbol{x}\\right)} &amp; \\Re{\\left(\\boldsymbol{x}\\right)}\\end{bmatrix}\\]为便于处理，令\\[\\boldsymbol{x}_r=\\begin{bmatrix}\\Re{\\left(\\boldsymbol{x}\\right)} \\\\\\Im{\\left(\\boldsymbol{x}\\right)}\\end{bmatrix}\\]因此有\\[{\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}^T \\varGamma_{\\alpha,f}^1 {\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}\\]同时考虑到式$f \\left( \\boldsymbol{x}_r \\right)$中虽然作为一个二次规划问题，但是其中间矩阵并不为正定导致难以处理。因此在这里可以引入一个辅助变量并令$\\boldsymbol{x}_r-\\boldsymbol{b}_r=\\boldsymbol{0}$，因此总结来说，对于该模型约束主要分为三个方面：  相似性度量  恒模约束  辅助变量约束此时有目标函数和约束条件为：\\[\\begin{aligned}\\min_{\\boldsymbol{b}_r,\\boldsymbol{x}_r,h} &amp;\\quad f(\\boldsymbol{x}_r) = \\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}} \\left[{\\left|{\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{b}_r \\right)}^T \\varGamma_{\\alpha,f}^1 {\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}\\right|}^2 +{\\left|{\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{b}_r \\right)}^T \\varGamma_{\\alpha,f}^2 {\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}\\right|}^2 \\right] \\\\s.t.&amp;\\quad \\begin{array}{l}{\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right)}^H \\chi_{n,r} {\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)}- \\vartheta-h=0 \\quad n\\in [1,2,\\cdots,N] \\\\{\\boldsymbol{x}_r}^T{\\boldsymbol{x}_r}=1 \\\\\\boldsymbol{x}_r-\\boldsymbol{b}_r=\\boldsymbol{0} \\\\h \\leq 0\\\\\\end{array}\\end{aligned}\\]定义目标函数为：\\[\\varrho \\left( \\boldsymbol{b}_r,\\boldsymbol{x}_r \\right)= f(\\boldsymbol{x}_r) = \\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}} \\left[{\\left|{\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{b}_r \\right)}^T \\varGamma_{\\alpha,f}^1 {\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}\\right|}^2 +{\\left|{\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{b}_r \\right)}^T \\varGamma_{\\alpha,f}^2 {\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}\\right|}^2 \\right]\\]因此，我们可以写出拉格朗日函数为：\\[\\begin{array}{ll}    \\mathcal{L} \\left( \\boldsymbol{x}_r,\\boldsymbol{b}_r,\\boldsymbol{\\lambda}_0,\\left\\{ \\lambda_n \\right\\} _{n=1}^{N},h \\right) =&amp;     \\varrho (\\boldsymbol{b}_r,\\boldsymbol{x}_r)+{\\boldsymbol{\\lambda }_0^T}\\left( \\boldsymbol{x}_r-\\boldsymbol{b}_r \\right) +\\frac{\\rho _0}{2}\\Vert\\boldsymbol{x}_r-\\boldsymbol{b}_r\\Vert^2\\\\    &amp;        +\\sum_{n=1}^N{\\lambda _{n}}\\left( \\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right) -\\vartheta -h \\right)\\\\    &amp;        +\\sum_{n=1}^N{\\frac{\\rho _{n}}{2}}\\Vert\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right) -\\vartheta -h\\Vert^2\\\\\\end{array}\\]  注意，这里所写的是增广拉格朗日函数。其中，$\\boldsymbol{\\lambda}0\\in \\mathbb{R}^{N\\times 1},{\\lambda}{n}\\in \\mathbb{R},n=1,2,\\cdots,N$为拉格朗日乘子参数；$\\rho_0,\\rho_1,\\cdots,\\rho_{n+1},\\cdots,\\rho_{N+1}$为罚函数参数项，用于控制算法收敛的进度。1. 算法详解采用ADMM算法求解。Step 1：求解$\\boldsymbol{x}_r^{k+1}$确定$\\boldsymbol{b}r^{k},\\boldsymbol{\\lambda}_0^{k},\\left{\\lambda_n^k \\right}{n=1}^N,h^k$。此时仅仅只有$\\boldsymbol{x}_r$变量，此时拉格朗日函数如下：\\[\\mathcal{L}_1\\left( \\boldsymbol{x}_r\\right)=\\boldsymbol{x}_r^T\\boldsymbol{A}\\boldsymbol{x}_r+\\boldsymbol{B}^T\\boldsymbol{x}_r+\\boldsymbol{C}\\]其中$\\boldsymbol{C}$为常数项，因此可以舍弃，故有：\\[\\begin{array}{ll}\\min\\limits_{\\boldsymbol{x}_r} &amp;\\mathcal{L}_1\\left( \\boldsymbol{x}_r\\right)=\\boldsymbol{x}_r^T\\boldsymbol{A}\\boldsymbol{x}_r+\\boldsymbol{B}^T\\boldsymbol{x}_r\\\\s.t. &amp; \\boldsymbol{x}_r^T\\boldsymbol{x}_r=1\\end{array}\\]其中有：\\[\\begin{array}{l}\\boldsymbol{A}=&amp;\\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}}\\left[\\boldsymbol{F}_{N,r}^T \\varGamma_{\\alpha,f}^{1,T}\\left( \\boldsymbol{F}_{N,r} \\boldsymbol{b}_r \\right){\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{b}_r \\right)}^T\\varGamma_{\\alpha,f}^1 {\\boldsymbol{F}_{N,r}}\\right. \\\\&amp;+\\left.\\boldsymbol{F}_{N,r}^T \\varGamma_{\\alpha,f}^{2,T}\\left( \\boldsymbol{F}_{N,r} \\boldsymbol{b}_r \\right){\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{b}_r \\right)}^T\\varGamma_{\\alpha,f}^2 {\\boldsymbol{F}_{N,r}}\\right]\\\\&amp;+\\sum\\limits_{n=1}^{N}\\frac{\\rho_n}{2}{\\chi_{n,r}\\left(\\boldsymbol{b}_r-\\boldsymbol{c}_r\\right) \\left(\\boldsymbol{b}_r-\\boldsymbol{c}_r\\right)^T\\chi_{n,r}^T}+\\frac{\\rho_0}{2}\\boldsymbol{I}\\\\\\end{array}\\]\\[\\begin{array}{l}  \\boldsymbol{B}^T=  &amp;  \\boldsymbol{\\lambda}_0^T-\\rho_0\\boldsymbol{b}_r^T+\\sum\\limits_{n=1}^{N} \\lambda_n {\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right)}^T \\chi_{n,r}^T-\\sum\\limits_{n=1}^N{\\rho_n \\boldsymbol{c}_r^T \\chi_{n,r}\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right){\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right)}^T\\chi_{n,r}^T}\\\\ &amp; -\\sum\\limits_{n=1}^N{\\rho_n (\\vartheta+h) (\\boldsymbol{b}_r-\\boldsymbol{c}_r)}^T\\chi_{n,r}^T\\end{array}\\]\\[\\begin{array}{l}    \\boldsymbol{C}=&amp;        \\frac{\\rho _0}{2}\\boldsymbol{b}_{r}^{T}\\boldsymbol{b}_r-\\boldsymbol{\\lambda }_{0}^{T}\\boldsymbol{b}_r-\\sum_{n=1}^N{\\lambda _n\\left( \\boldsymbol{c}_{r}^{T}\\chi _{n,r}\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right) +\\vartheta +h \\right)}\\\\    &amp;        +\\sum_{n=1}^N{\\frac{\\rho _n}{2}\\left[ \\left( \\vartheta +h \\right) ^2+\\boldsymbol{c}_{r}^{T}\\chi _{n,r}\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right) \\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}^{T}\\boldsymbol{c}_r \\right]}\\\\\\end{array}\\]显然,，其中$\\boldsymbol{A}$为一个对称矩阵。此时可以写出该问题的KKT条件为：\\[\\begin{array}{l}  &amp; {\\left( 2\\boldsymbol{A}+2\\boldsymbol{I} \\right)} \\boldsymbol{x}_r^*+\\boldsymbol{B}=0  \\\\  &amp; {\\left( \\boldsymbol{x}_r^{*} \\right)}^T\\boldsymbol{x}_r^{*}=1  \\end{array}\\]注意：在这里$\\boldsymbol{B}^T\\boldsymbol{x}$为标量，其对于$\\boldsymbol{x}$求导并不等于$\\boldsymbol{B}^T$，而是$\\boldsymbol{B}$。因此可以求得$\\boldsymbol{x}^{*}_r =- \\left( 2\\boldsymbol{A}+2\\boldsymbol{I} \\right)^{\\dagger}\\boldsymbol{B}$。  其中${\\left( \\cdot \\right)}^{\\dagger}$为矩阵的伪逆。这里并不一定为恒模的，应该如何处理？若$\\boldsymbol{A}$为正定矩阵，则其是一个QCQP(Quadratic Constraint Quadratic Programming)问题，但是在这里其为不定矩阵。Step 2： 求解$\\boldsymbol{b}_r^{k+1}$此时目标问题为一个无约束二次规划问题。与Step 1 中类似，有：\\[\\mathcal{L}_2 \\left( \\boldsymbol{b}_r \\right) = \\boldsymbol{b}_r^T \\boldsymbol{A}_2 \\boldsymbol{b}_r + \\boldsymbol{B}_2^T\\boldsymbol{b}_r+ \\boldsymbol{C}_2\\]其中有：\\[\\begin{array}{l}\\boldsymbol{A}_2=&amp;\\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}}\\left[\\boldsymbol{F}_{N,r}^T \\varGamma_{\\alpha,f}^{1,T}\\left( \\boldsymbol{F}_{N,r} \\boldsymbol{x}_r \\right){\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}^T\\varGamma_{\\alpha,f}^1 {\\boldsymbol{F}_{N,r}}\\right. +\\left.\\boldsymbol{F}_{N,r}^T \\varGamma_{\\alpha,f}^{2,T}\\left( \\boldsymbol{F}_{N,r} \\boldsymbol{x}_r \\right){\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}^T\\varGamma_{\\alpha,f}^2 {\\boldsymbol{F}_{N,r}}\\right]\\\\&amp;+\\sum\\limits_{n=1}^{N}\\frac{\\rho_n}{2}{\\chi_{n,r}^T \\left(\\boldsymbol{x}_r-\\boldsymbol{c}_r\\right) \\left(\\boldsymbol{x}_r-\\boldsymbol{c}_r\\right)^T\\chi_{n,r}}+\\frac{\\rho_0}{2}\\boldsymbol{I}\\\\\\end{array}\\]\\[\\boldsymbol{B}_2^T=  -\\boldsymbol{\\lambda}_0^T-\\rho_0\\boldsymbol{x}_r^T+\\sum\\limits_{n=1}^{N}{\\lambda}_n {\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)}^T \\chi_{n,r}-\\sum\\limits_{n=1}^N{\\rho_n \\boldsymbol{c}_r^T \\chi_{n,r}\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right){\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)}^T\\chi_{n,r}^T}\\]\\[\\begin{array}{l}  \\boldsymbol{C}_2=  &amp;  \\boldsymbol{x}_r^T\\boldsymbol{x}_r  -\\boldsymbol{u}^T\\boldsymbol{x}_r - \\sum\\limits_{n=1}^{N}{v_n{\\left( {\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)}^T\\chi_{n,r}\\boldsymbol{c}_r+\\vartheta + h\\right)}}+ \\sum\\limits_{n=1}^{N}{\\frac{\\rho_n}{2}}{\\left( \\vartheta+h \\right)}^2 \\\\  &amp;+\\sum\\limits_{n=1}^{N}{\\frac{\\rho_n}{2}\\left( {\\left( \\vartheta + h \\right)}^2  + \\boldsymbol{c}_r^T \\chi_{n,r}^T\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right){\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)}^T\\chi_{n,r}\\boldsymbol{c}_r\\right)}\\end{array}\\]对于无约束二次规划问题，对于$\\boldsymbol{A}_2$的不同情况处理方式也不同。  当$\\boldsymbol{A}_2 \\succeq 0$时，该问题为严格凸问题。  当$\\boldsymbol{A}_2 \\succ 0$时，该问题为凸问题。  当$\\boldsymbol{A}_2 \\prec 0$或为不定矩阵时，该问题为非凸问题。在这里$$矩阵Step 3：求解$h^{k+1}$我们注意到此时$\\mathcal{L} \\left( \\boldsymbol{x}_r,\\boldsymbol{b}_r,\\boldsymbol{u},\\lbrace v_n \\rbrace _{n=1}^{N},h \\right)$中仅仅只有最后两项与$h$有关。\\[\\begin{array}{ll}    \\mathcal{L} \\left( \\boldsymbol{x}_r,\\boldsymbol{b}_r,\\boldsymbol{\\lambda}_0,\\left\\{ \\lambda_n \\right\\} _{n=1}^{N},h \\right) =&amp;     \\varrho (\\boldsymbol{b}_r,\\boldsymbol{x}_r)+{\\boldsymbol{\\lambda }_0^T}\\left( \\boldsymbol{x}_r-\\boldsymbol{b}_r \\right) +\\frac{\\rho _0}{2}\\Vert\\boldsymbol{x}_r-\\boldsymbol{b}_r\\Vert^2\\\\    &amp;        +\\sum_{n=1}^N{\\lambda _{n}}\\left( \\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right) -\\vartheta -h \\right)\\\\    &amp;        +\\sum_{n=1}^N{\\frac{\\rho _{n}}{2}}\\Vert\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right) -\\vartheta -h\\Vert^2\\\\\\end{array}\\]当固定除$h$的其它变量时，该式对于$h$而言即为一个二次表达式。有\\[\\begin{array}{ll}\\min\\limits_h &amp; \\mathcal{L} \\left( h \\right) = \\varrho h^2+\\varpi h+c \\\\s.t. &amp; h \\leq0\\end{array}\\]其中有\\[\\varrho = \\sum\\limits_{n=1}^{N}\\frac{\\rho_n}{2}\\]\\[\\varpi = -\\sum\\limits_{n=1}^{N} \\left[ \\rho_n \\left( \\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)^T\\chi_{n,r} {\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)^T}-\\vartheta\\right) + \\lambda_n \\right]\\]\\[\\begin{array}{ll}c=&amp; \\varrho \\left( \\boldsymbol{b}_r^{k+1},\\boldsymbol{x}_r^{k+1} \\right)+\\boldsymbol{\\lambda}_0^{k+1}\\left( \\boldsymbol{x}_r^{k+1}-\\boldsymbol{b}_r^{k+1} \\right)+\\frac{\\rho_0}{2}\\Vert \\boldsymbol{x}_r^{k+1}-\\boldsymbol{b}_r^{k+1} \\Vert\\\\&amp;+\\sum\\limits_{n=1}^N{\\lambda _{n}}\\left( \\left( \\boldsymbol{x}_r^{k+1}-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}\\left( \\boldsymbol{b}_r^{k+1}-\\boldsymbol{c}_r \\right) -\\vartheta\\right)\\\\&amp;+\\sum\\limits_{n=1}^N{\\frac{\\rho _{n}}{2}}\\Vert\\left( \\boldsymbol{x}_r^{k+1}-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}\\left( \\boldsymbol{b}_r^{k+1}-\\boldsymbol{c}_r \\right) -\\vartheta\\Vert^2\\end{array}\\]为了处理这里的不等式约束，我们可以添加对数障碍函数进行处理，即$\\gamma \\left( h \\right) = -r \\ln \\left( -h \\right) $，这里$r$是我们所设定的系数项，且其应该接近于0。因此我们有：\\[\\mathcal{L} \\left( h,r \\right)=\\varrho h^2+\\varpi h + c+\\gamma \\left( h \\right)\\]令$\\frac {\\partial{\\mathcal{L} \\left( h,r \\right)}}{\\partial h}=0$，可以得到：\\[2\\varrho h^2 +\\varpi h +r =0\\]显然我们可以解得:\\[h=\\frac{-\\varpi \\pm\\sqrt{\\varpi^2-8\\varrho r} }{4\\varrho}\\]考虑到$r \\rightarrow 0$，保留满足$h\\leq 0$的解有：\\[h=\\frac{-\\varpi -\\sqrt{\\varpi^2-8\\varrho r} }{4\\varrho}\\]Step 4：求解$\\boldsymbol{\\lambda}0,{\\lbrace \\lambda_n \\rbrace}{n=1}^N$最后考虑求解拉格朗日系数。该等式对于拉格朗日系数为一次方程，我们仅需要对其进行求导即可。有：\\[\\frac{\\partial{\\mathcal{L}\\left(\\boldsymbol{\\lambda}_0\\right)}}{\\partial \\boldsymbol{\\lambda}_0}= \\boldsymbol{x}_r^{k+1}-\\boldsymbol{b}_r^{k+1}\\]\\[\\frac{\\partial{\\mathcal{L}\\left({\\lambda}_n\\right)}}{\\partial {\\lambda}_n}=\\left( \\left( \\boldsymbol{x}_r^{k+1}-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}\\left( \\boldsymbol{b}_r^{k+1}-\\boldsymbol{c}_r \\right) -\\vartheta-h^{k+1}\\right)\\]2. 仿真复现使用MATLAB对于该论文算法进行复现，其中完整代码可见该仓库2.1 所碰见的问题在计算过程中发现$\\boldsymbol{c}_r$与$\\boldsymbol{x}_r$并不满足我们所设定的约束条件；其次是$\\boldsymbol{x}_r-\\boldsymbol{b}_r=0$的约束事实上也并没有被满足。这显然取决于两个拉格朗日系数项并没有满足所需条件。% Example:% :param :% :return :% detailed description:%------------------------------------------------------------------------------% Created by: Xinyu Huang.% On: 16/04/2024.% Copyright (C) 2024 Xinyu Huang (learning_huang@163.com).% All Rights Reserved.% Unauthorized copying of this file, via any medium is strictly prohibited.% Proprietary and confidential.%------------------------------------------------------------------------------clc;clear;close all;% % Parameter Settingflag_PlotAndExport = 1;flag_Sparse = 0;flag_PrintLog = 1;num_Mator = 1;maxnum = 20; % 最大迭代次数threshhold = 20;% % Data IntializationSN = 64;M = 4;x = exp(1j*2*pi*rand(N,1))/sqrt(N);xr = [real(x);imag(x)]; br = xr; fs = 5e6;T = N/fs;fc = 1e5;temp_B = 2e5;c = generator_LFM(fs,fc,temp_B,T)/sqrt(N);cr = [real(c);imag(c)];[chi_matrix, Taf_1, Taf_2, FNr, omega_alpha_1] = Generate_data(N, M, flag_Sparse, threshhold);% % ADMM参数初始化h = -0.1; % 相似度约束辅助变量lambda_0 = 1*ones(2*N,1);lambda_1 = 1*ones(N,1); rho_0 = 1;rho_1 = 10*ones(N,1); % 罚函数项系数t = 8; % 障碍函数系数vartheta = 0.01/sqrt(N); % 参考信号相关度阈值% % Data Record% % The initial parameter Caculations_xr_init = RadarSignal(xr(1:N));s_cr = RadarSignal(cr(1:N));Tar_out = zeros(maxnum,1);if flag_PrintLog    fid = fopen('./output_files/WCS_sparse.log','w+');    fprintf(fid,'The initial xr.\\n');    PrintToLog(fid, s_xr_init);end% % ADMMforwaitbar = forWaitbar(maxnum);for i_maxnum = 1:maxnum    % % Step 1 , Solving the x_r.     xr = Update_xr(N, FNr, xr, br, cr, omega_alpha_1, rho_0, rho_1, lambda_0, lambda_1, h, vartheta, Taf_1, Taf_2, chi_matrix, flag_Sparse);    % % Step 2 , Solving the b_r    br = Update_br(N, FNr, xr, br, cr, omega_alpha_1, rho_0, rho_1, lambda_0, lambda_1, h, vartheta, Taf_1, Taf_2, chi_matrix, flag_Sparse);    % Step 3 , Solving the h    h = Update_h(xr, br, cr, rho_1, lambda_1, vartheta, t, chi_matrix, flag_Sparse);    % Step 4 , Solving the u, v_n    [lambda_0, lambda_1] = Update_lambda(xr, br, cr, rho_0, rho_1, lambda_0, lambda_1, h, vartheta, chi_matrix, flag_Sparse);    forwaitbar.show_bar;    Tar_out(i_maxnum) = Caculate_TarFunCValue(xr,Taf_1,Taf_2,flag_Sparse,omega_alpha_1);endif flag_PlotAndExport     figure;    plot(Tar_out);    exportgraphics(gcf, './output_files/out_tar_value_iters.pdf','ContentType', 'vector');    figure;    Analysis_Sidelobe(xr(1:N),xr(1:N),'bool_draw',1);hold on;    Analysis_Sidelobe(cr(1:N),cr(1:N),'bool_draw',1);hold off;    legend('xr','cr');    exportgraphics(gcf, './output_files/out_sidelobe.pdf','ContentType', 'vector')    figure;    plot(xr(1:N));hold on;    plot(cr(1:N));hold off;    legend('xr','cr');    exportgraphics(gcf, './output_files/xr_and_cr.pdf','ContentType', 'vector');    Analysis_CS_DFSM(fs,xr(1:N),fs/N,M,'bool_draw',1);    exportgraphics(gcf, './output_files/xr_CS.pdf','ContentType', 'vector');    Analysis_CS_DFSM(fs,cr(1:N),fs/N,M,'bool_draw',1);    exportgraphics(gcf, './output_files/cr_CS.pdf','ContentType', 'vector');end% % The post-parameter after optimization and signal cs_xr_post = RadarSignal(xr(1:N));if flag_PrintLog    fprintf(fid,'The xr after optimization.\\n');    PrintToLog(fid, s_xr_post);    fprintf(fid,'The cr.\\n');    PrintToLog(fid, s_cr);    fclose(fid);end% The Qudratic Target Functionfunction [y,grady] = quadobj(x,Q,f,c)    y = 1/2*x'*Q*x + f'*x + c;    if nargout &gt; 1        grady = Q*x + f;    endend% The Qudratic Constraint Functionfunction [y,yeq,grady,gradyeq] = quadconstr(x,H,k,d)    jj = length(H);  % jj is the number of equality constraints    yeq = zeros(1,jj);    for i = 1:jj        yeq(i) = 1/2*x'*H{i}*x + k{i}'*x + d{i};    end    y = [];    if nargout &gt; 2        gradyeq = zeros(length(x),jj);        for i = 1:jj            gradyeq(:,i) = H{i}*x + k{i};        end    end    grady = [];end% The Hessian Functionfunction hess = quadhess(lambda,Q,H)    hess = Q;    jj = length(H);  % jj is the number of equality constraints    for i = 1:jj        hess = hess + lambda.eqnonlin(i)*H{i};    endend% Print The signal information to the logfunction [] = PrintToLog(fid, s_signal)    fprintf(fid,'The signal parameter.\\n');    fprintf(fid,['PAPR: %.2f.\\n', ...                'PSL: %.2f dB.\\n',...                'ISL: %.2f dB.\\n',...                'PSLR: %.2f dB.\\n',...                'ISLR: %.2f dB.\\n'...                ],s_signal.PAPR,s_signal.PSL,s_signal.ISL,s_signal.PSLR,s_signal.ISLR);                % 'Target Function Value: %.2d\\n'end% The Definition of update parametetrfunction xr = Update_xr(N, FNr, xr_in, br, cr, omega_alpha_1, rho_0, rho_1, lambda_0, lambda_1, h, vartheta, Taf_1, Taf_2, chi_matrix, flag_Sparse)    if flag_Sparse        A1_1 = 0;        A1_2 = 0;        for i_temp = 1:(N+1)*N/2                A1_1_1 = FNr'*(Taf_1{i_temp})'*(FNr*br);                A1_1_2 = FNr'*(Taf_2{i_temp})'*(FNr*br);                A1_1 = A1_1 + omega_alpha_1(i_temp)*(A1_1_1*A1_1_1'+A1_1_2*A1_1_2')/((N+1)*N*10/2);        end        for i_temp = 1:N            A1_temp_3= (chi_matrix{i_temp})'*(br-cr);            A1_2 = A1_2 + rho_1(i_temp)*(A1_temp_3*A1_temp_3');        end        A1_3 = rho_0/2*eye(2*N,2*N);        A1 = A1_1 + A1_2 + A1_3;        BT1_1 = lambda_0'; % Caculate the matrix B_1^T        BT1_2 = -rho_0*br';        BT1_3 = 0;        BT1_4 = 0;        BT1_5 = 0;        for i_temp = 1:N            BT1_3 = BT1_3 + lambda_1(i_temp)*(br-cr)'*(chi_matrix{i_temp}');            BT1_4_temp1 = (br-cr)'*(chi_matrix{i_temp})';            BT1_4 = BT1_4 + rho_1(i_temp)*cr'*(BT1_4_temp1*BT1_4_temp1');            BT1_5 = -(vartheta+h)*rho_1(i_temp)*(br-cr)'*(chi_matrix{i_temp});        end        BT1 = BT1_1 + BT1_2 + BT1_3 + BT1_4 + BT1_5;    else        A1_temp1 = pagemtimes(pagemtimes(FNr,\"transpose\",Taf_1,\"transpose\"),FNr*br); % 子项1.1        A1_temp1 = pagemtimes(A1_temp1,\"none\",A1_temp1,\"transpose\");        A1_11 = sum(bsxfun(@times, A1_temp1, reshape(omega_alpha_1, 1, 1, [])),3); % 加权求和        A1_temp2 = pagemtimes(pagemtimes(FNr,\"transpose\",Taf_2,\"transpose\"),FNr*br); % 子项1.2        A1_temp2 = pagemtimes(A1_temp2,\"none\",A1_temp2,\"transpose\");        A1_12 = sum(bsxfun(@times, A1_temp2, reshape(omega_alpha_1, 1, 1, [])),3); % 加权求和        A1_temp3 = pagemtimes(chi_matrix,\"transpose\",br-cr,\"none\");        A1_temp3 = pagemtimes(A1_temp3,\"none\",A1_temp3,\"transpose\");        A1_2 = sum(bsxfun(@times, A1_temp3, reshape(rho_1, 1, 1, [])),3);        A1_3 = rho_0/2*eye(2*N,2*N);        A1 = A1_11 + A1_12 + A1_2 + A1_3;        % Caculate the matrix B_1^T        BT1_1 = lambda_0';        BT1_2 = -rho_0*br';        BT1_3_temp1 = pagemtimes(br-cr,\"transpose\",chi_matrix,\"transpose\");        BT1_3 = sum(bsxfun(@times, BT1_3_temp1, reshape(lambda_1, 1, 1, [])), 3);        BT1_4_temp1 = pagemtimes(chi_matrix,\"none\",br-cr,\"none\");        BT1_4_temp1 = pagemtimes(cr,\"transpose\",pagemtimes(BT1_4_temp1,\"none\",BT1_4_temp1,\"transpose\"),\"none\");        BT1_4 = -sum(bsxfun(@times, BT1_4_temp1, reshape(rho_1, 1, 1, [])), 3);        BT1_5_temp1 = pagemtimes(br-cr,\"transpose\",chi_matrix,\"none\");        BT1_5 = -(vartheta+h)*sum(bsxfun(@times, BT1_5_temp1, reshape(rho_1, 1, 1, [])), 3);        BT1 = BT1_1 + BT1_2 + BT1_3 + BT1_4 + BT1_5;    end    temp_H = cell(1);temp_k= cell(1);temp_d= cell(1);    temp_H{1} = eye(2*N)*2;    temp_k{1} = zeros(2*N,1);    temp_d{1} = -1;    options = optimoptions(@fmincon,'Algorithm','interior-point',...        'SpecifyObjectiveGradient',true,'SpecifyConstraintGradient',true,...        'HessianFcn',@(x,lambda)quadhess(lambda,A1/2,temp_H),'Display','off');    [xr,~,~,~] = fmincon(@(x) quadobj(x,A1/2,BT1',0), xr_in,[],[],[],[],[],[],...        @(x) quadconstr(x,temp_H,temp_k,temp_d),options);endfunction br = Update_br(N, FNr, xr, br_in, cr, omega_alpha_1, rho_0, rho_1, lambda_0, lambda_1, h, vartheta, Taf_1, Taf_2, chi_matrix, flag_Sparse)    if flag_Sparse        A2_1 = 0;        A2_2 = 0;        for i_temp = 1:(N+1)*N/2            A2_temp1 = FNr'*(Taf_1{i_temp})'*(FNr*xr);            A2_temp2 = FNr'*(Taf_2{i_temp})'*(FNr*xr);            A2_1 = A2_1 + omega_alpha_1(i_temp)*(A2_temp1*A2_temp1'+A2_temp2*A2_temp2'/((N+1)*N*10/2));        end        for i_temp = 1:N            A2_temp3 = (chi_matrix{i_temp})'*(xr-cr);            A2_2 = A2_2 + rho_1(i_temp)*(A2_temp3*A2_temp3');        end        A2_3 = rho_0/2*eye(2*N,2*N);        A2 = A2_1 + A2_2 + A2_3;        BT2_1 = -lambda_0';        BT2_2 = rho_0*xr';        BT2_3 = 0;        BT2_4 = 0;        BT2_5 = 0;        for i_temp = 1:N            BT2_3 = BT2_3 + lambda_1(i_temp)*(xr-cr)'*chi_matrix{i_temp};            BT2_4_temp1 = chi_matrix{i_temp}*(xr-cr);            BT2_4 = -rho_1(i_temp)*cr'*(BT2_4_temp1*BT2_4_temp1');            BT2_5 = -(vartheta+h)*rho_1(i_temp)*(xr-cr)'*(chi_matrix{i_temp});        end        BT2 = BT2_1 + BT2_2 + BT2_3 + BT2_4 + BT2_5;    else        A2_temp1 = pagemtimes(pagemtimes(FNr,\"transpose\",Taf_1,\"transpose\"),FNr*xr); % 子项1.1        A2_temp1 = pagemtimes(A2_temp1,\"none\",A2_temp1,\"transpose\");        A2_11 = sum(bsxfun(@times, A2_temp1, reshape(omega_alpha_1, 1, 1, [])),3); % 加权求和        A2_temp2 = pagemtimes(pagemtimes(FNr,\"transpose\",Taf_2,\"transpose\"),FNr*xr); % 子项1.2        A2_temp2 = pagemtimes(A2_temp2,\"none\",A2_temp2,\"transpose\");        A2_12 = sum(bsxfun(@times, A2_temp2, reshape(omega_alpha_1, 1, 1, [])),3); % 加权求和        A2_1 = A2_11 + A2_12;        A2_temp3 = pagemtimes(chi_matrix,\"transpose\",xr-cr,\"none\");        A2_temp3 = pagemtimes(A2_temp3,\"none\",A2_temp3,\"transpose\");        A2_2 = sum(bsxfun(@times, A2_temp3, reshape(rho_1, 1, 1, [])),3);        A2_3 = rho_0/2*eye(2*N,2*N);        A2 = A2_1 + A2_2 + A2_3;        BT2_1 = -lambda_0';        BT2_2 = rho_0*xr';        BT2_3_temp1 = pagemtimes(xr-cr,\"transpose\",chi_matrix,\"none\");        BT2_3 = sum(bsxfun(@times,BT2_3_temp1,reshape(lambda_1,1,1,[])),3);        BT2_4_temp1 = pagemtimes(chi_matrix,\"none\",xr-cr,\"none\");        BT2_4_temp1 = pagemtimes(cr,\"transpose\",pagemtimes(BT2_4_temp1,\"none\",BT2_4_temp1,\"transpose\"),\"none\");        BT2_4 = -sum(bsxfun(@times, BT2_4_temp1, reshape(rho_1, 1, 1, [])), 3);        BT2_5_temp1 = pagemtimes(xr-cr,\"transpose\",chi_matrix,\"none\");        BT2_5 = -(vartheta+h)*sum(bsxfun(@times, BT2_5_temp1, reshape(rho_1, 1, 1, [])), 3);        BT2 = BT2_1 + BT2_2 + BT2_3 + BT2_4 + BT2_5;    end    temp_H = cell(1);temp_k= cell(1);temp_d= cell(1);    temp_H{1} = eye(2*N)*2;    temp_k{1} = zeros(2*N,1);    temp_d{1} = -1;    options = optimoptions(@fmincon,'Algorithm','interior-point',...        'SpecifyObjectiveGradient',true,'SpecifyConstraintGradient',true,...        'HessianFcn',@(x,lambda)quadhess(lambda,A2/2,temp_H),'Display','off');    [br,~,~,~] = fmincon(@(x) quadobj(x,A2/2,BT2',0), br_in,[],[],[],[],[],[],...        @(x) quadconstr(x,temp_H,temp_k,temp_d),options);endfunction h = Update_h(xr, br, cr, rho_1, lambda_1, vartheta, t, chi_matrix, flag_Sparse)    A3 = sum(rho_1)/2;    BT3_1 = -sum(lambda_1);    if flag_Sparse        BT3_2 = 0;        for i_temp = 1:N            BT3_2 = -rho_1(i_temp)*(xr-cr)'*chi_matrix{i_temp}*(br-cr);        end    else        BT3_2_temp = pagemtimes(xr-cr,\"transpose\",pagemtimes(chi_matrix,\"none\",br-cr,\"none\"),\"none\");        BT3_2 = sum(bsxfun(@times, BT3_2_temp, reshape(-rho_1, 1, 1, [])), 3);    end    BT3_3 = vartheta*sum(rho_1);    BT3 = BT3_1 + BT3_2 + BT3_3;    h = (-BT3-sqrt(BT3^2+8*A3/t))/(4*A3);endfunction [lambda_0, lambda_1] = Update_lambda(xr, br, cr, rho_0, rho_1, lambda_0_in, lambda_1_in, h, vartheta, chi_matrix, flag_Sparse)    lambda_0 = lambda_0_in + rho_0*(xr-br);    lambda_1 = zeros(size(lambda_1_in));    if flag_Sparse        for i_n = 1:N            lambda_1(i_n) = lambda_1_in(i_n) + rho_1(i_n)*((xr-cr)'*chi_matrix{i_n}*(br-cr)-h-vartheta);        end    else        lambda_1 = reshape(pagemtimes(xr-cr,\"transpose\",pagemtimes(chi_matrix,\"none\",br-cr,\"none\"),\"none\")-h-vartheta, [], 1).*rho_1 + lambda_1_in;    endendfunction [chi_matrix, Taf_1, Taf_2, FNr, omega_alpha_1] = Generate_data(N, M, flag_Sparse, threshhold)    % FNr    FN = dftmtx(N);     Fshift = zeros(N);    Fshift(1:N/2,N/2+1:end) = eye(N/2);    Fshift(N/2+1:end,1:N/2) = eye(N/2);    FN = Fshift*FN;    FNr = complex2real(FN);    % omega_alpha_1    omega_alpha_1 = ones((N+1)*N/2,1);    if flag_Sparse        chi_matrix = cell(N,1);        for i_temp = 1:N            matrix_temp = zeros(N,N);            matrix_temp(i_temp,i_temp) = 1;            chi_matrix{i_temp} = sparse(complex2real(matrix_temp));        end        % 循环谱计算矩阵 20240410 Modified        % 考虑到循环谱计算矩阵是对称的，在这里我们可以仅仅计算接近一半的数值，由N^2 -&gt; (N+1)*N/2，减小接近一半的计算量与存储空间        temp_m = -M/2+1:M/2;        Taf_1 = cell((N+1)*N/2,1);        Taf_2 = cell((N+1)*N/2,1);        i_temp = 0;        for temp_1 = 1:N            for temp_2 = temp_1:N                i_temp = i_temp + 1;                temp_B = max(1-temp_1, 1-temp_2);                temp_A = min (N-temp_1, N-temp_2);                temp_n = temp_m((temp_m&lt;=temp_A) &amp; (temp_m&gt;=temp_B));                if isempty(temp_n)                    temp_taf = zeros(N,N);                else                    temp_p = temp_1 + temp_n;                    temp_q = temp_2 + temp_n;                    temp_taf = zeros(N,N);                    temp_taf(temp_p(1):temp_p(end),temp_q(1):temp_q(end)) = eye(length(temp_q));                end                temp_taf_1 = [real(temp_taf),-imag(temp_taf);imag(temp_taf),real(temp_taf)];                temp_taf_2 = [imag(temp_taf),-real(temp_taf);real(temp_taf),imag(temp_taf)];                Taf_1{i_temp} = sparse(temp_taf_1);                Taf_2{i_temp} = sparse(temp_taf_2);                if abs(temp_1-temp_2) &lt; threshhold                    omega_alpha_1(i_temp) = 0.01;                else                    omega_alpha_1(i_temp) = 10;                end            end        end        else        chi_matrix = zeros(2*N,2*N,N); % 相似性约束矩阵        for i_temp = 1:N            matrix_temp = zeros(N,N);            matrix_temp(i_temp,i_temp) = 1;            chi_matrix(:,:,i_temp) = complex2real(matrix_temp);        end        Taf_1 = zeros(2*N,2*N,(N+1)*N/2);        Taf_2 = zeros(2*N,2*N,(N+1)*N/2);        temp_m = -M/2+1:M/2;        i_temp = 0;        for temp_1 = 1:N            for temp_2 = temp_1:N                i_temp = i_temp + 1;                temp_B = max(1-temp_1, 1-temp_2);                temp_A = min (N-temp_1, N-temp_2);                temp_n = temp_m((temp_m&lt;=temp_A) &amp; (temp_m&gt;=temp_B));                if isempty(temp_n)                    temp_taf = zeros(N,N);                else                    temp_p = temp_1 + temp_n;                    temp_q = temp_2 + temp_n;                    temp_taf = zeros(N,N);                    temp_taf(temp_p(1):temp_p(end),temp_q(1):temp_q(end)) = eye(length(temp_q));                end                temp_taf_1 = [real(temp_taf),-imag(temp_taf);imag(temp_taf),real(temp_taf)];                temp_taf_2 = [imag(temp_taf),-real(temp_taf);real(temp_taf),imag(temp_taf)];                Taf_1(:,:,i_temp) = sparse(temp_taf_1);                Taf_2(:,:,i_temp) = sparse(temp_taf_2);                if abs(temp_1-temp_2) &lt; threshhold                     omega_alpha_1(i_temp) = 0.01;                else                    omega_alpha_1(i_temp) = 10;                end            end        end      endendfunction TarFunCValue = Caculate_TarFunCValue(xr,Taf_1,Taf_2,flag_Sparse,omega_alpha_1)    TarFunCValue = 0;    if flag_Sparse        for iter_i = 1:length(omega_alpha_1)            TarFunCValue = TarFunCValue + omega_alpha_1(iter_i)*(xr'*Taf_1{iter_i}*xr + xr'*Taf_2{iter_i}*xr);        end    else        TarFunCValue = TarFunCValue + sum(bsxfun(@times,pagemtimes(pagemtimes(xr,\"transpose\",Taf_1,\"none\"),\"none\",xr,\"none\"),reshape(omega_alpha_1, 1, 1, [])),3);        TarFunCValue = TarFunCValue + sum(bsxfun(@times,pagemtimes(pagemtimes(xr,\"transpose\",Taf_2,\"none\"),\"none\",xr,\"none\"),reshape(omega_alpha_1, 1, 1, [])),3);    endend3. 总结分析"
  },
  
  {
    "title": "博客搭建",
    "url": "/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/",
    "categories": "Other",
    "tags": "Jekyll",
    "date": "2024-03-13 16:47:23 +0800",
    





    
    "snippet": "配置说明修改左下角图标显示问题说明：左下角默认具有推特、feed 等图标，但是可能有一些并不使用，以及想添加一些非默认的联系方式解决方案：修改_data/contact.yml文件中的代码，示例如下。注释并不使用的联系方式类型，保留所需要的。- type: email  icon: \"fas fa-envelope\"  noblank: true # open link in current...",
    "content": "配置说明修改左下角图标显示问题说明：左下角默认具有推特、feed 等图标，但是可能有一些并不使用，以及想添加一些非默认的联系方式解决方案：修改_data/contact.yml文件中的代码，示例如下。注释并不使用的联系方式类型，保留所需要的。- type: email  icon: \"fas fa-envelope\"  noblank: true # open link in current tab  url: # Fill with your homepage对于不在示例中的联系方式的填写，需要填写其中的 url，此外其所使用的图标代码来自于 Fontawesome网站。其中一些常用的网站的图标均有，例如其中 Bilibili 的图标代码则为fa-brands fa-bilibili。添加自定义脚注问题说明：由于图片引用至其它网站，希望。解决方案：在_data/locales/lang.yml文件中添加如下代码：在_include/footer.html文件中添加如下代码：文档更新时间未显示问题说明：新文档更新时间不显示，示例文档可以正常显示，但复制黏贴一个示例文档的样本，结果为不显示。测试发现，仅有原文件存在page.last_modified_at属性，其它文档均没有该属性，而更新时间是通过输出该属性来显示的，因此对于其它文件而言无法正常显示。查看_plugins/posts-lastmod-hook.rb文件，其代码如下：Jekyll::Hooks.register :posts, :post_init do |post|  commit_num = `git rev-list --count HEAD \"#{ post.path }\"`  if commit_num.to_i &gt; 1    lastmod_date = `git log -1 --pretty=\"%ad\" --date=iso \"#{ post.path }\"`    post.data['last_modified_at'] = lastmod_date  endend其中commit_num记录了 git 提交次数，其通过是否存在多次 git 提交来判断，但是本项目挂载在 github 上，测试发现即便多次修改提交文件，返回的该变量值仍为 1，因此导致了仅在本地使用jekyll serve指令进行本地测试时该参数将为 1，因此不显示更新时间。自定义修改问题说明：在使用非LQIP图像时，网页所使用默认格式会加载使用shimmer特效，个人并不喜欢这一特效，希望关闭。解决方案：查看_include/refactor-content.html文件，其中代码如下：                  &lt;!-- lazy-load images --&gt;其通过代码判断图像的_lqip属性来给_class分配值，若为真则分配为blur，若为假则分配为shimmer，其中若分配为shimmer则会使得在显示时呈现闪光特效。因此我们在最后添加一行代码，无论合适都给_class分配为null。    添加Live2D模型为了添加一个Live2D模型，我们需要自己创建相应的js脚本并调用，以及一个Live2D的模型资源。&lt;script src=\"/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887\"&gt;&lt;/script&gt;&lt;script&gt;L2Dwidget.init({\"pluginModelPath\":\"assets/\",\"model\":{\"jsonPath\":\"/live2dw/assets/koharu.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":300},\"mobile\":{\"show\":false},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginRootPath\":\"live2dw/\",\"tagMode\":false});&lt;/script&gt;  免费图标素材网站"
  },
  
  {
    "title": "A Coordinate Descent Framework to Design Low PSL ISL Sequences 论文阅读",
    "url": "/posts/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%95-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBPSL/",
    "categories": "科研记录",
    "tags": "论文阅读",
    "date": "2023-06-21 13:56:37 +0800",
    





    
    "snippet": "论文地址：A Coordinate Descent Framework to Design Low PSL ISL Sequences期刊/会议：IEEE TRANSACTIONS ON Signal Processing发表时间：20171. 问题建模在雷达系统的脉冲压缩过程中，通常希望具有低的峰值旁瓣电平（Peak Sidelobe Level, PSL）避免弱目标被强目标的旁瓣所遮蔽；...",
    "content": "论文地址：A Coordinate Descent Framework to Design Low PSL ISL Sequences期刊/会议：IEEE TRANSACTIONS ON Signal Processing发表时间：20171. 问题建模在雷达系统的脉冲压缩过程中，通常希望具有低的峰值旁瓣电平（Peak Sidelobe Level, PSL）避免弱目标被强目标的旁瓣所遮蔽；同时，为了减轻相近目标的分布式杂波的回波的影响，我们需要信号具有低的积分旁瓣电平（Integrated Sidelobe Level, ISL）。考虑一个相位编码序列$\\boldsymbol{x}=[x_1,x_2,…,x_N]^T\\in \\mathbb{C} ^N$，其自相关函数$r_k$、PSL、ISL的定义如下。\\[r_k=\\sum_{i=1}^{N-1}{x_{i}^{*}x_{i+k}}\\quad k=0,1,...,N-1\\]\\[PSL=max\\left\\{ \\left| r_k \\right| \\right\\} _{k=1}^{k=N-1}\\]\\[ISL=\\sum_{k=1}^{N-1}{\\left| r_k \\right|^2}\\]此外，在雷达信号中，因需要保持最大的发射功率以获得最大的信噪比，故常常希望晶体管工作在饱和区、信号幅度始终为最大，即恒模约束。因此，针对于连续相位约束与离散相位约束，该问题可以表示为一个优化问题。\\[P^{\\infty}\\lbrace \\begin{matrix} \\underset{\\boldsymbol{x}}{\\min}&amp; f_1(\\boldsymbol{x}),f_2(\\boldsymbol{x})\\\\s.t.&amp; \\boldsymbol{x}\\in \\Omega _{\\infty}\\\\\\end{matrix} ,P^M\\lbrace \\begin{matrix} \\underset{\\boldsymbol{x}}{\\min}&amp; f_1(\\boldsymbol{x}),f_2(\\boldsymbol{x})\\\\ s.t.&amp; \\boldsymbol{x}\\in \\Omega _M\\\\\\end{matrix}\\]\\[f_1\\left( \\boldsymbol{x} \\right) =\\max \\left\\{ \\left| r_k \\right|^2 \\right\\} _{k=1}^{k=N-1}\\]\\[f_2\\left( \\boldsymbol{x} \\right) =\\underset{k=1}{\\overset{k=N-1}{\\sum{\\,}}}\\left| r_k \\right|^2\\]\\[\\Omega _{\\infty}=\\left\\{ \\boldsymbol{x}\\in \\mathbb{C} ^N\\left| \\, \\right. \\left| x_i \\right|,i=1,...,N \\right\\}\\]\\[\\Omega _M=\\left\\{ \\boldsymbol{x}\\left| \\, \\right. x_i\\in \\varPsi _M,i=1,...,N \\right\\}\\]\\[\\varPsi _M=\\{1,\\bar{\\omega},...,\\bar{\\omega}^{M-1}\\},\\bar{\\omega}=e^{j\\frac{2\\pi}{M}}\\]针对于多目标优化问题，通常不能寻找到对于所有目标函数都最优的一个解，已经被证明的是，对于多目标问题而言，通常存在一个帕累托最优解集（Pareto-optimal solutions），也可称为帕累托最优界；其表征着在这一界限上若想使某一个目标函数更优，则必然会导致其它目标函数的损失。针对于多目标优化问题，常用的方法有进化算法如粒子群算法、遗传算法、灰狼算法等，线性化技术也是常用于多目标优化的方法之一，即使用多个目标函数的凸组合代替原目标函数集，从而将多目标优化转化为一个单目标优化问题，在本问题中，由于两个目标函数的度量尺度相同，因此使用标量化技术是可行的措施，而标量化所需要的权系数则需要人为依据经验选定。因此目标函数可以转化为如下所示形式。\\[P^{\\infty ,\\theta}\\left\\{ \\begin{matrix}    \\underset{\\boldsymbol{x}}{\\min}&amp;        f_{\\theta}(\\boldsymbol{x})\\\\    s.t.&amp;        \\boldsymbol{x}\\in \\Omega _{\\infty}\\\\\\end{matrix} \\right. ,P^{M,\\theta}\\left\\{ \\begin{matrix}    \\underset{\\boldsymbol{x}}{\\min}&amp;        f_{\\theta}(\\boldsymbol{x})\\\\    s.t.&amp;        \\boldsymbol{x}\\in \\Omega _M\\\\\\end{matrix} \\right.\\]\\[\\begin{aligned}    f_{\\theta}(\\boldsymbol{x})=&amp;\\,\\,\\theta f_1(\\boldsymbol{x})+(1-\\theta )f_2(\\boldsymbol{x})\\\\    =&amp;\\max_{k=1,...,N-1} \\left[ \\theta |r_k|^2+(1-\\theta )\\sum_{l=1}^{N-1}{|r_l|^2} \\right]\\\\\\end{aligned}\\]2. 算法原理2.1 坐标下降法在恒模约束下，上式对应优化问题成为了一个非凸的、NP难的问题，在这里引入优化方法中常使用的坐标下降法对其进行处理，原本我们需要针对于一个维度为N的向量进行优化，坐标下降法即固定其中某一个维度，对其进行逐变量优化，如下所示：\\[P_{d,\\boldsymbol{x}^{(n)}}^{\\infty ,\\theta}\\left\\{ \\begin{matrix}    \\underset{x_d}{\\min}&amp;        f_{\\theta}(x_d;\\boldsymbol{x}_{-d}^{(n)})\\\\    s.t.&amp;        \\left| x_d \\right|=1\\\\\\end{matrix} \\right. ,P_{d,\\boldsymbol{x}^{(n)}}^{M,\\theta}\\left\\{ \\begin{matrix}    \\underset{x_d}{\\min}&amp;        f_{\\theta}(x_d;\\boldsymbol{x}_{-d}^{(n)})\\\\    s.t.&amp;        x_d\\in \\varPsi _M\\\\\\end{matrix} \\right.\\]\\[\\boldsymbol{x}_{-d}^{(n)}=\\left[ x_{1}^{(n)},...,x_{d-1}^{(n)},x_{d+1}^{(n)},...,x_{N}^{(n)} \\right] ^T\\in \\mathbb{C} ^{N-1}\\]\\[f_{\\theta}(x_d;\\boldsymbol{x}_{-d}^{(n)})=f_{\\theta}(x_{1}^{(n)},...,x_{d-1}^{(n)},x_d,x_{d+1}^{(n)},...,x_{N}^{(n)}).\\]针对于恒模约束下的坐标下降算法，文献表示使用最大块提升策略可以使其稳定的收敛到一个可行点，最大块提升策略即在逐变量优化的过程中只接受拥有最大块改进的块更新部分。在这里我们同样使用该策略进行更新。对于连续相位情况，目标函数变为了单变量函数，因此针对于目标函数我们可以进行改写。\\[\\begin{aligned}    r_k(x_d)=&amp;x_d(x_{d+k}^{(n)})^*1_A(d+k)+(x_{d-k}^{(n)})x_{d}^{*}1_A(d-k)\\\\    &amp;+\\sum_{i=1,i\\ne \\left\\{ d,d-k \\right\\}}^{N-k}{x_{i}^{(n)}(x_{i+k}^{(n)})^*}, k=1,...,N-1,\\\\\\end{aligned}\\]\\[\\mathbf{1}_A(x)=\\left\\{ \\begin{aligned}    1\\quad &amp;\\mathrm{if} \\mathrm{x}\\in A\\\\    0\\quad &amp;\\mathrm{else}\\\\\\end{aligned} \\right. \\quad A=\\left\\{ 1,2,...,N \\right\\}\\]注意到$r_k\\left( x_d \\right)$仅与$x_d$有关，我们定义$c_{dk}=\\sum\\nolimits_{i=1,i\\ne \\left{ d,d-k \\right}}^{N-k}{x_{i}^{(n)}(x_{i+k}^{(n)})^}$，$a_{dk}\\triangleq (x_{d+k}^{(n)})^1A(d+k)$，$b{dk}=(x_{d-k}^{(n)})1_A(d-k)$，故有：\\[r_k(x_d)=a_{dk}x_d+b_{dk}x_{d}^{*}+c_{dk}\\]因此有：\\[P_{d,\\boldsymbol{x}^{(n)}}^{\\infty ,\\theta}\\left\\{ \\begin{matrix}    \\underset{x_d}{\\min}&amp;        \\max_{k=1,...,N-1} \\left[ \\theta \\left| r_k(x_d) \\right|^2+(1-\\theta )\\sum_{l=1}^{N-1}{\\left| r_l(x_d) \\right|^2} \\right]\\\\    s.t.&amp;        \\left| x_d \\right|=1\\\\\\end{matrix} \\right. \\\\P_{d,\\boldsymbol{x}^{(n)}}^{M,\\theta}\\left\\{ \\begin{matrix}    \\underset{x_d}{\\min}&amp;        \\max_{k=1,...,N-1} \\left[ \\theta \\left| r_k(x_d) \\right|^2+(1-\\theta )\\sum_{l=1}^{N-1}{\\left| r_l(x_d) \\right|^2} \\right]\\\\    s.t.&amp;        x_d\\in \\varPsi _M\\\\\\end{matrix} \\right.\\]2.2 连续相位编码算法2.3 离散相位编码算法"
  },
  
  {
    "title": "读后感-《长日将尽》",
    "url": "/posts/%E8%AF%BB%E5%90%8E%E6%84%9F-%E9%95%BF%E6%97%A5%E5%B0%86%E5%B0%BD/",
    "categories": "个人记录",
    "tags": "读书笔记",
    "date": "2023-03-30 12:00:00 +0800",
    





    
    "snippet": "读后感作品简介长日将尽(The Remains  of the Day)是阅读感悟我从中感到一种忧伤、一种怜悯、一种无可奈何。我们或者说我自己亦是如此。这本书以史蒂文斯–一位英国式管家/男仆的第一人称讲述展开，在他已是中老年之时（文中未具体提及，不过大抵如此）的一次旅游记述展开，穿插以他旧时辉煌时光的回忆。他的父亲是一位英国男仆、管家，而他也是在父亲的教育之下希冀着成为一名伟大的管家；至于关...",
    "content": "读后感作品简介长日将尽(The Remains  of the Day)是阅读感悟我从中感到一种忧伤、一种怜悯、一种无可奈何。我们或者说我自己亦是如此。这本书以史蒂文斯–一位英国式管家/男仆的第一人称讲述展开，在他已是中老年之时（文中未具体提及，不过大抵如此）的一次旅游记述展开，穿插以他旧时辉煌时光的回忆。他的父亲是一位英国男仆、管家，而他也是在父亲的教育之下希冀着成为一名伟大的管家；至于关于伟大管家的定义，也是文中不断谈及的一点，他的心中对此有些见解并为之不断奋斗。可是，他将这看的如此之重。在他的父亲病逝之时，他忙于工作；在与他暗生情愫的女管家肯特小姐，他克制自己的情感，以致于肯特小姐因失望而与他人订婚之时，他亦是无动于衷；在他的主人克林顿公爵渐渐走偏、沦为纳粹的棋子之时，他仍因自己对于管家应绝对详细主人的原则而对此视而不见。待到克林顿府的繁华散去，昔日忙碌不再，新任主人容许他有一个假期之时，他才在脑海中开始审视自己过去的每一个选择。他意识到自己的过去种种，似乎错失了一些重要的东西，关于亲情、关于爱情、也关于他的理想。对于父亲的病逝，对于肯特小姐的示好、失落、绝望，对于克林顿公爵的误入歧途，他都无动于衷，他沉溺在自己的工作或者说是理想之中，脑海中不允许其它事物的存在。“不识庐山真面目，只缘身在此山中。”其实面对很多时刻，或许他可以有更好的选择，或许他面临的并非是非此即彼的选择，或许，他本可以…在书的最后一章中，似乎也有意表现出史蒂文斯的反思，但是，他似乎有些不愿面对。“那么你呢，史蒂文斯先生？你回到达林顿府以后又会有什么样的未来在等着你呢？”“喔，不管等着我的到底是什么，本恩太太，我只知道那不可能是一片虚空。如果是的话倒好了，可是不会的，只有工作、工作、做不完的工作。”他每一次放弃自己的情感，都从中得到一种对于理想更一步接近的自豪，沉溺于抛弃一切追求心中所想的偏执之中。或许对于他而言如此做是幸福的，至少在他做出决定之后是如此。只是，对于这样的做法，我并不苟同，最后史蒂文斯旅行将尽之时的怅然若失亦是如此，即便他很快又回到了那一种对于工作的偏执之中。“一定要爱着些什么，恰似草木对光阴的深情。”不是吗？希望你我都有更多关于生活，当自己日渐迟暮，回忆起过往之时，不会有这样的缺憾。"
  },
  
  {
    "title": "Getting Started",
    "url": "/posts/getting-started/",
    "categories": "",
    "tags": "",
    "date": "2019-08-09 00:00:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "Write A New Post",
    "url": "/posts/write-a-new-post/",
    "categories": "",
    "tags": "",
    "date": "2019-08-08 00:00:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "Text And Typography",
    "url": "/posts/text-and-typography/",
    "categories": "",
    "tags": "",
    "date": "2019-08-08 00:00:00 +0800",
    





    
    "snippet": "",
    "content": ""
  }
  
]

